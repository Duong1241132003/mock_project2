        -:    0:Source:/home/duong/MediaPlayerApp/src/repositories/PlaylistRepository.cpp
        -:    0:Graph:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/repositories/PlaylistRepository.cpp.gcno
        -:    0:Data:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/repositories/PlaylistRepository.cpp.gcda
        -:    0:Runs:6
        -:    1:// Project includes
        -:    2:#include "repositories/PlaylistRepository.h"
        -:    3:#include "utils/Logger.h"
        -:    4:
        -:    5:// System includes
        -:    6:#include <fstream>
        -:    7:#include <filesystem>
        -:    8:#include <sstream>
        -:    9:#include <algorithm>
        -:   10:
        -:   11:namespace fs = std::filesystem;
        -:   12:
        -:   13:namespace media_player 
        -:   14:{
        -:   15:namespace repositories 
        -:   16:{
        -:   17:
    #####:   18:PlaylistRepository::PlaylistRepository(const std::string& storagePath)
    #####:   19:    : m_storagePath(storagePath)
        -:   20:{
    #####:   21:    ensureStorageDirectoryExists();
    #####:   22:    loadFromDisk();
        -:   23:    
    #####:   24:    LOG_INFO("PlaylistRepository initialized with storage path: " + storagePath);
    #####:   25:}
        -:   26:
    #####:   27:PlaylistRepository::~PlaylistRepository() 
        -:   28:{
    #####:   29:    saveToDisk();
    #####:   30:    LOG_INFO("PlaylistRepository destroyed");
    #####:   31:}
------------------
_ZN12media_player12repositories18PlaylistRepositoryD0Ev:
    #####:   27:PlaylistRepository::~PlaylistRepository() 
        -:   28:{
        -:   29:    saveToDisk();
        -:   30:    LOG_INFO("PlaylistRepository destroyed");
    #####:   31:}
------------------
_ZN12media_player12repositories18PlaylistRepositoryD2Ev:
    #####:   27:PlaylistRepository::~PlaylistRepository() 
        -:   28:{
    #####:   29:    saveToDisk();
    #####:   30:    LOG_INFO("PlaylistRepository destroyed");
    #####:   31:}
------------------
        -:   32:
    #####:   33:bool PlaylistRepository::save(const models::PlaylistModel& playlist) 
        -:   34:{
    #####:   35:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:   36:    
        -:   37:    try 
        -:   38:    {
    #####:   39:        std::string id = playlist.getId();
        -:   40:        
    #####:   41:        if (id.empty()) 
        -:   42:        {
    #####:   43:            LOG_ERROR("Cannot save playlist with empty ID");
    #####:   44:            return false;
        -:   45:        }
        -:   46:        
        -:   47:        // Save to cache
    #####:   48:        m_cache[id] = playlist;
        -:   49:        
        -:   50:        // Persist to disk
    #####:   51:        std::string filePath = getPlaylistFilePath(id);
        -:   52:        
    #####:   53:        if (!serializePlaylist(playlist, filePath)) 
        -:   54:        {
    #####:   55:            LOG_ERROR("Failed to serialize playlist to disk: " + id);
    #####:   56:            return false;
        -:   57:        }
        -:   58:        
    #####:   59:        LOG_INFO("Playlist saved: " + playlist.getName() + " (ID: " + id + ")");
    #####:   60:        return true;
    #####:   61:    }
    =====:   62:    catch (const std::exception& e) 
        -:   63:    {
    =====:   64:        LOG_ERROR("Exception in save: " + std::string(e.what()));
    =====:   65:        return false;
    =====:   66:    }
    #####:   67:}
        -:   68:
    #####:   69:std::optional<models::PlaylistModel> PlaylistRepository::findById(const std::string& id) 
        -:   70:{
    #####:   71:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:   72:    
    #####:   73:    auto it = m_cache.find(id);
        -:   74:    
    #####:   75:    if (it != m_cache.end()) 
        -:   76:    {
    #####:   77:        return it->second;
        -:   78:    }
        -:   79:    
    #####:   80:    LOG_DEBUG("Playlist not found: " + id);
    #####:   81:    return std::nullopt;
    #####:   82:}
        -:   83:
    #####:   84:std::vector<models::PlaylistModel> PlaylistRepository::findAll() 
        -:   85:{
    #####:   86:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:   87:    
    #####:   88:    std::vector<models::PlaylistModel> result;
    #####:   89:    result.reserve(m_cache.size());
        -:   90:    
    #####:   91:    for (const auto& pair : m_cache) 
        -:   92:    {
    #####:   93:        result.push_back(pair.second);
        -:   94:    }
        -:   95:    
    #####:   96:    return result;
    #####:   97:}
        -:   98:
    #####:   99:bool PlaylistRepository::update(const models::PlaylistModel& playlist) 
        -:  100:{
    #####:  101:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:  102:    
    #####:  103:    std::string id = playlist.getId();
        -:  104:    
        -:  105:    // Check cache directly (don't call exists() which would deadlock)
    #####:  106:    if (m_cache.find(id) == m_cache.end()) 
        -:  107:    {
    #####:  108:        LOG_WARNING("Cannot update non-existent playlist: " + id);
    #####:  109:        return false;
        -:  110:    }
        -:  111:    
        -:  112:    // Update cache
    #####:  113:    m_cache[id] = playlist;
        -:  114:    
        -:  115:    // Persist to disk
    #####:  116:    std::string filePath = getPlaylistFilePath(id);
        -:  117:    
    #####:  118:    if (!serializePlaylist(playlist, filePath)) 
        -:  119:    {
    #####:  120:        LOG_ERROR("Failed to update playlist on disk: " + id);
    #####:  121:        return false;
        -:  122:    }
        -:  123:    
    #####:  124:    LOG_INFO("Playlist updated: " + playlist.getName());
    #####:  125:    return true;
    #####:  126:}
        -:  127:
    #####:  128:bool PlaylistRepository::remove(const std::string& id) 
        -:  129:{
    #####:  130:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:  131:    
    #####:  132:    auto it = m_cache.find(id);
        -:  133:    
    #####:  134:    if (it == m_cache.end()) 
        -:  135:    {
    #####:  136:        LOG_WARNING("Cannot remove non-existent playlist: " + id);
    #####:  137:        return false;
        -:  138:    }
        -:  139:    
    #####:  140:    std::string name = it->second.getName();
        -:  141:    
        -:  142:    // Remove from cache
    #####:  143:    m_cache.erase(it);
        -:  144:    
        -:  145:    // Remove from disk
    #####:  146:    std::string filePath = getPlaylistFilePath(id);
        -:  147:    
        -:  148:    try 
        -:  149:    {
    #####:  150:        if (fs::exists(filePath)) 
        -:  151:        {
    #####:  152:            fs::remove(filePath);
        -:  153:        }
        -:  154:        
    #####:  155:        LOG_INFO("Playlist removed: " + name + " (ID: " + id + ")");
    #####:  156:        return true;
        -:  157:    }
    =====:  158:    catch (const fs::filesystem_error& e) 
        -:  159:    {
    =====:  160:        LOG_ERROR("Failed to remove playlist file: " + std::string(e.what()));
    =====:  161:        return false;
    =====:  162:    }
    #####:  163:}
        -:  164:
    #####:  165:bool PlaylistRepository::exists(const std::string& id) 
        -:  166:{
    #####:  167:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
    #####:  168:    return m_cache.find(id) != m_cache.end();
    #####:  169:}
        -:  170:
    #####:  171:bool PlaylistRepository::saveAll(const std::vector<models::PlaylistModel>& playlists) 
        -:  172:{
    #####:  173:    bool allSuccess = true;
        -:  174:    
    #####:  175:    for (const auto& playlist : playlists) 
        -:  176:    {
    #####:  177:        if (!save(playlist)) 
        -:  178:        {
    #####:  179:            allSuccess = false;
        -:  180:        }
        -:  181:    }
        -:  182:    
    #####:  183:    return allSuccess;
        -:  184:}
        -:  185:
    #####:  186:void PlaylistRepository::clear() 
        -:  187:{
    #####:  188:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:  189:    
        -:  190:    // Remove all files
        -:  191:    try 
        -:  192:    {
    #####:  193:        for (const auto& pair : m_cache) 
        -:  194:        {
    #####:  195:            std::string filePath = getPlaylistFilePath(pair.first);
        -:  196:            
    #####:  197:            if (fs::exists(filePath)) 
        -:  198:            {
    #####:  199:                fs::remove(filePath);
        -:  200:            }
    #####:  201:        }
        -:  202:    }
    =====:  203:    catch (const fs::filesystem_error& e) 
        -:  204:    {
    =====:  205:        LOG_ERROR("Error clearing playlists: " + std::string(e.what()));
    =====:  206:    }
        -:  207:    
    #####:  208:    m_cache.clear();
    #####:  209:    LOG_INFO("All playlists cleared");
    #####:  210:}
        -:  211:
    #####:  212:size_t PlaylistRepository::count() const 
        -:  213:{
    #####:  214:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
    #####:  215:    return m_cache.size();
    #####:  216:}
        -:  217:
    #####:  218:std::optional<models::PlaylistModel> PlaylistRepository::findByName(const std::string& name) 
        -:  219:{
    #####:  220:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:  221:    
    #####:  222:    for (const auto& pair : m_cache) 
        -:  223:    {
    #####:  224:        if (pair.second.getName() == name) 
        -:  225:        {
    #####:  226:            return pair.second;
        -:  227:        }
        -:  228:    }
        -:  229:    
    #####:  230:    return std::nullopt;
    #####:  231:}
        -:  232:
    #####:  233:std::vector<models::PlaylistModel> PlaylistRepository::searchByName(const std::string& query) 
        -:  234:{
    #####:  235:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:  236:    
    #####:  237:    std::vector<models::PlaylistModel> results;
    #####:  238:    std::string lowerQuery = query;
    #####:  239:    std::transform(lowerQuery.begin(), lowerQuery.end(), lowerQuery.begin(), ::tolower);
        -:  240:    
    #####:  241:    for (const auto& pair : m_cache) 
        -:  242:    {
    #####:  243:        std::string lowerName = pair.second.getName();
    #####:  244:        std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);
        -:  245:        
    #####:  246:        if (lowerName.find(lowerQuery) != std::string::npos) 
        -:  247:        {
    #####:  248:            results.push_back(pair.second);
        -:  249:        }
    #####:  250:    }
        -:  251:    
    #####:  252:    return results;
    #####:  253:}
        -:  254:
    #####:  255:bool PlaylistRepository::loadFromDisk() 
        -:  256:{
    #####:  257:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:  258:    
        -:  259:    try 
        -:  260:    {
    #####:  261:        if (!fs::exists(m_storagePath)) 
        -:  262:        {
    #####:  263:            LOG_INFO("Storage path does not exist, creating: " + m_storagePath);
    #####:  264:            ensureStorageDirectoryExists();
    #####:  265:            return true;
        -:  266:        }
        -:  267:        
    #####:  268:        int loadedCount = 0;
        -:  269:        
    #####:  270:        for (const auto& entry : fs::directory_iterator(m_storagePath)) 
        -:  271:        {
    #####:  272:            if (entry.is_regular_file() && entry.path().extension() == ".playlist") 
        -:  273:            {
    #####:  274:                auto playlist = deserializePlaylist(entry.path().string());
        -:  275:                
    #####:  276:                if (playlist) 
        -:  277:                {
    #####:  278:                    m_cache[playlist->getId()] = *playlist;
    #####:  279:                    loadedCount++;
        -:  280:                }
    #####:  281:            }
    #####:  282:        }
        -:  283:        
    #####:  284:        LOG_INFO("Loaded " + std::to_string(loadedCount) + " playlists from disk");
    #####:  285:        return true;
        -:  286:    }
    =====:  287:    catch (const fs::filesystem_error& e) 
        -:  288:    {
    =====:  289:        LOG_ERROR("Error loading playlists from disk: " + std::string(e.what()));
    =====:  290:        return false;
    =====:  291:    }
    #####:  292:}
        -:  293:
    #####:  294:bool PlaylistRepository::saveToDisk() 
        -:  295:{
    #####:  296:    std::lock_guard<std::recursive_mutex> lock(m_mutex);
        -:  297:    
        -:  298:    try 
        -:  299:    {
    #####:  300:        ensureStorageDirectoryExists();
        -:  301:        
    #####:  302:        for (const auto& pair : m_cache) 
        -:  303:        {
    #####:  304:            std::string filePath = getPlaylistFilePath(pair.first);
    #####:  305:            serializePlaylist(pair.second, filePath);
    #####:  306:        }
        -:  307:        
    #####:  308:        LOG_INFO("Saved " + std::to_string(m_cache.size()) + " playlists to disk");
    #####:  309:        return true;
        -:  310:    }
    =====:  311:    catch (const std::exception& e) 
        -:  312:    {
    =====:  313:        LOG_ERROR("Error saving playlists to disk: " + std::string(e.what()));
    =====:  314:        return false;
    =====:  315:    }
    #####:  316:}
        -:  317:
    #####:  318:std::string PlaylistRepository::getPlaylistFilePath(const std::string& id) const 
        -:  319:{
    #####:  320:    return m_storagePath + "/" + id + ".playlist";
        -:  321:}
        -:  322:
    #####:  323:bool PlaylistRepository::serializePlaylist(const models::PlaylistModel& playlist, 
        -:  324:                                          const std::string& filePath) 
        -:  325:{
        -:  326:    try 
        -:  327:    {
    #####:  328:        std::ofstream file(filePath);
        -:  329:        
    #####:  330:        if (!file.is_open()) 
        -:  331:        {
    #####:  332:            LOG_ERROR("Failed to open file for writing: " + filePath);
    #####:  333:            return false;
        -:  334:        }
        -:  335:        
        -:  336:        // Write playlist metadata
    #####:  337:        file << "ID:" << playlist.getId() << "\n";
    #####:  338:        file << "NAME:" << playlist.getName() << "\n";
    #####:  339:        file << "COUNT:" << playlist.getItemCount() << "\n";
    #####:  340:        file << "ITEMS:\n";
        -:  341:        
    #####:  342:        const char tab = '\t';
    #####:  343:        for (const auto& item : playlist.getItems()) 
        -:  344:        {
    #####:  345:            std::string title = item.getTitle();
    #####:  346:            std::string artist = item.getArtist();
    #####:  347:            for (char& c : title) if (c == tab || c == '\n' || c == '\r') c = ' ';
    #####:  348:            for (char& c : artist) if (c == tab || c == '\n' || c == '\r') c = ' ';
    #####:  349:            file << item.getFilePath() << tab << title << tab << artist << "\n";
    #####:  350:        }
        -:  351:        
    #####:  352:        file.close();
    #####:  353:        return true;
    #####:  354:    }
    =====:  355:    catch (const std::exception& e) 
        -:  356:    {
    =====:  357:        LOG_ERROR("Exception serializing playlist: " + std::string(e.what()));
    =====:  358:        return false;
    =====:  359:    }
        -:  360:}
        -:  361:
    #####:  362:std::optional<models::PlaylistModel> PlaylistRepository::deserializePlaylist(const std::string& filePath) 
        -:  363:{
        -:  364:    try 
        -:  365:    {
    #####:  366:        std::ifstream file(filePath);
        -:  367:        
    #####:  368:        if (!file.is_open()) 
        -:  369:        {
    #####:  370:            LOG_ERROR("Failed to open file for reading: " + filePath);
    #####:  371:            return std::nullopt;
        -:  372:        }
        -:  373:        
    #####:  374:        std::string line;
    #####:  375:        std::string id, name;
        -:  376:        struct ItemLine { std::string path; std::string title; std::string artist; };
    #####:  377:        std::vector<ItemLine> itemLines;
        -:  378:        
    #####:  379:        bool readingItems = false;
        -:  380:        
    #####:  381:        while (std::getline(file, line)) 
        -:  382:        {
    #####:  383:            if (line.empty()) 
        -:  384:            {
    #####:  385:                continue;
        -:  386:            }
        -:  387:            
    #####:  388:            if (line == "ITEMS:") 
        -:  389:            {
    #####:  390:                readingItems = true;
    #####:  391:                continue;
        -:  392:            }
        -:  393:            
    #####:  394:            if (readingItems) 
        -:  395:            {
    #####:  396:                ItemLine il;
    #####:  397:                size_t t1 = line.find('\t');
    #####:  398:                if (t1 != std::string::npos) {
    #####:  399:                    il.path = line.substr(0, t1);
    #####:  400:                    size_t t2 = line.find('\t', t1 + 1);
    #####:  401:                    if (t2 != std::string::npos) {
    #####:  402:                        il.title = line.substr(t1 + 1, t2 - (t1 + 1));
    #####:  403:                        il.artist = line.substr(t2 + 1);
        -:  404:                    } else {
    #####:  405:                        il.title = line.substr(t1 + 1);
        -:  406:                    }
        -:  407:                } else {
    #####:  408:                    il.path = line;
        -:  409:                }
    #####:  410:                itemLines.push_back(il);
    #####:  411:            }
        -:  412:            else 
        -:  413:            {
    #####:  414:                size_t colonPos = line.find(':');
        -:  415:                
    #####:  416:                if (colonPos != std::string::npos) 
        -:  417:                {
    #####:  418:                    std::string key = line.substr(0, colonPos);
    #####:  419:                    std::string value = line.substr(colonPos + 1);
        -:  420:                    
    #####:  421:                    if (key == "ID") 
        -:  422:                    {
    #####:  423:                        id = value;
        -:  424:                    }
    #####:  425:                    else if (key == "NAME") 
        -:  426:                    {
    #####:  427:                        name = value;
        -:  428:                    }
    #####:  429:                }
        -:  430:            }
        -:  431:        }
        -:  432:        
    #####:  433:        file.close();
        -:  434:        
    #####:  435:        if (id.empty() || name.empty()) 
        -:  436:        {
    #####:  437:            LOG_ERROR("Invalid playlist file format: " + filePath);
    #####:  438:            return std::nullopt;
        -:  439:        }
        -:  440:        
        -:  441:        // Create playlist with original ID (not a new one)
    #####:  442:        models::PlaylistModel playlist(name);
    #####:  443:        playlist.setId(id);  // Preserve original ID from file
        -:  444:        
        -:  445:        // Add items
    #####:  446:        for (const auto& il : itemLines) 
        -:  447:        {
    #####:  448:            if (il.path.empty()) continue;
    #####:  449:            models::MediaFileModel media(il.path);
    #####:  450:            if (media.isValid()) 
        -:  451:            {
    #####:  452:                if (!il.title.empty()) media.setTitle(il.title);
    #####:  453:                if (!il.artist.empty()) media.setArtist(il.artist);
    #####:  454:                playlist.addItem(media);
        -:  455:            }
    #####:  456:        }
        -:  457:        
    #####:  458:        return playlist;
    #####:  459:    }
    =====:  460:    catch (const std::exception& e) 
        -:  461:    {
    =====:  462:        LOG_ERROR("Exception deserializing playlist: " + std::string(e.what()));
    =====:  463:        return std::nullopt;
    =====:  464:    }
        -:  465:}
        -:  466:
    #####:  467:void PlaylistRepository::ensureStorageDirectoryExists() 
        -:  468:{
        -:  469:    try 
        -:  470:    {
    #####:  471:        if (!fs::exists(m_storagePath)) 
        -:  472:        {
    #####:  473:            fs::create_directories(m_storagePath);
    #####:  474:            LOG_INFO("Created storage directory: " + m_storagePath);
        -:  475:        }
        -:  476:    }
    =====:  477:    catch (const fs::filesystem_error& e) 
        -:  478:    {
    =====:  479:        LOG_ERROR("Failed to create storage directory: " + std::string(e.what()));
    =====:  480:    }
    #####:  481:}
        -:  482:
        -:  483:} // namespace repositories
        -:  484:} // namespace media_player
