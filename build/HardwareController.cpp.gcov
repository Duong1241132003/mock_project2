        -:    0:Source:/home/duong/MediaPlayerApp/src/controllers/HardwareController.cpp
        -:    0:Graph:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/controllers/HardwareController.cpp.gcno
        -:    0:Data:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/controllers/HardwareController.cpp.gcda
        -:    0:Runs:6
        -:    1:// Project includes
        -:    2:#include "controllers/HardwareController.h"
        -:    3:#include "utils/Logger.h"
        -:    4:#include "config/AppConfig.h"
        -:    5:
        -:    6:// System includes
        -:    7:#include <sstream>
        -:    8:#include <regex>
        -:    9:#include <filesystem>
        -:   10:#include <algorithm>
        -:   11:#include <dirent.h>
        -:   12:
        -:   13:namespace media_player 
        -:   14:{
        -:   15:namespace controllers 
        -:   16:{
        -:   17:
        -:   18:// Constants cho S32K144 protocol
        -:   19:static const int BAUD_RATE_S32K144 = 115200;
        -:   20:static const int ADC_MIN_VALUE = 0;
        -:   21:static const int ADC_MAX_VALUE = 100;
        -:   22:static const int BTN_MIN_VALUE = 1;
        -:   23:static const int BTN_MAX_VALUE = 4;
        -:   24:// Cho phép khoảng trắng sau dấu ':' để phù hợp dữ liệu thực tế từ board
        -:   25:static const std::regex ADC_PATTERN(R"(!ADC:\s*(\d{1,3})\s*!)");
        -:   26:static const std::regex BTN_PATTERN(R"(!BTN:\s*(\d{1,2})\s*!)");
        -:   27:
       18:   28:HardwareController::HardwareController(
        -:   29:    std::shared_ptr<services::ISerialCommunication> serialComm,
        -:   30:    std::shared_ptr<models::PlaybackStateModel> playbackStateModel
       18:   31:)
       18:   32:    : m_serialComm(serialComm)
       18:   33:    , m_playbackStateModel(playbackStateModel)
       18:   34:    , m_lastReconnectAttempt(std::chrono::steady_clock::now())
       18:   35:    , m_reconnectInterval(std::chrono::milliseconds(2000))
        -:   36:{
        -:   37:    // Setup serial callbacks
       36:   38:    m_serialComm->setDataCallback(
      18*:   39:        [this](const std::string& data) 
        -:   40:        {
    #####:   41:            onSerialDataReceived(data);
    #####:   42:        }
        -:   43:    );
        -:   44:    
        -:   45:    // Use DEBUG level for serial errors to avoid spamming logs during disconnects
       18:   46:    m_serialComm->setErrorCallback(
    #####:   47:        [](const std::string& error) 
        -:   48:        {
    #####:   49:            LOG_DEBUG("Serial error: " + error);
    #####:   50:        }
        -:   51:    );
        -:   52:    
       36:   53:    LOG_INFO("HardwareController initialized");
       18:   54:}
        -:   55:
       18:   56:HardwareController::~HardwareController() 
        -:   57:{
       18:   58:    m_stopScan = true;
       18:   59:    if (m_scanThread.joinable())
        -:   60:    {
        6:   61:        m_scanThread.join();
        -:   62:    }
        -:   63:
       18:   64:    disconnect();
       36:   65:    LOG_INFO("HardwareController destroyed");
       18:   66:}
        -:   67:
        6:   68:bool HardwareController::initialize() 
        -:   69:{
        -:   70:    // Thử auto connect trước
        6:   71:    if (autoConnect())
        -:   72:    {
    #####:   73:        return true;
        -:   74:    }
        -:   75:    
        -:   76:    // Fallback: thử port mặc định từ config
        6:   77:    std::string port = config::AppConfig::SERIAL_PORT_DEFAULT;
        6:   78:    int baudRate = BAUD_RATE_S32K144;
        -:   79:    
        6:   80:    return connect(port, baudRate);
        6:   81:}
        -:   82:
        6:   83:bool HardwareController::autoConnect()
        -:   84:{
        6:   85:    std::lock_guard<std::mutex> lock(m_connectionMutex);
        -:   86:    
        6:   87:    if (m_isScanning)
        -:   88:    {
    #####:   89:        return false;
        -:   90:    }
        -:   91:    
        6:   92:    if (isConnected())
        -:   93:    {
    #####:   94:        return true;
        -:   95:    }
        -:   96:    
        6:   97:    m_isScanning = true;
        -:   98:    
        6:   99:    if (m_scanThread.joinable())
        -:  100:    {
    #####:  101:        m_stopScan = true;
    #####:  102:        m_scanThread.join();
        -:  103:    }
        -:  104:    
        6:  105:    m_stopScan = false;
        6:  106:    m_isScanning = true;
        -:  107:    
        -:  108:    // Launch scanning in a managed thread
       12:  109:    m_scanThread = std::thread([this]() {
       12:  110:        LOG_INFO("Starting background hardware scan...");
        -:  111:        
        6:  112:        auto ports = scanAvailablePorts();
        6:  113:        bool connected = false;
        -:  114:        
       6*:  115:        for (const auto& port : ports)
        -:  116:        {
        -:  117:            // Check if we should stop scanning 
        6:  118:            if (m_stopScan) break;
        -:  119:            
    #####:  120:            LOG_DEBUG("Trying port: " + port);
        -:  121:            
    #####:  122:            if (connect(port, BAUD_RATE_S32K144))
        -:  123:            {
    #####:  124:                LOG_INFO("Successfully connected to S32K144 on port: " + port);
    #####:  125:                connected = true;
    #####:  126:                break;
        -:  127:            }
        -:  128:        }
        -:  129:        
       6*:  130:        if (!connected && !m_stopScan)
        -:  131:        {
    #####:  132:            LOG_WARNING("Auto-connect failed, no compatible device found");
        -:  133:        }
        -:  134:        
        6:  135:        m_isScanning = false;
       12:  136:    });
        -:  137:    
        6:  138:    return false; // Return false immediately as connection happens asynchronously
        6:  139:}
        -:  140:
        6:  141:std::vector<std::string> HardwareController::scanAvailablePorts()
        -:  142:{
        6:  143:    std::vector<std::string> ports;
        -:  144:    
        -:  145:    // Quét /dev/ttyUSB* và /dev/ttyACM* trên Linux
       12:  146:    const std::vector<std::string> prefixes = {"/dev/ttyUSB", "/dev/ttyACM"};
        -:  147:    
       18:  148:    for (const auto& prefix : prefixes)
        -:  149:    {
      132:  150:        for (int i = 0; i < 10; ++i)
        -:  151:        {
      120:  152:            std::string portPath = prefix + std::to_string(i);
        -:  153:            
      120:  154:            if (std::filesystem::exists(portPath))
        -:  155:            {
        6:  156:                ports.push_back(portPath);
        -:  157:            }
      120:  158:        }
        -:  159:    }
        -:  160:
        -:  161:    // Quét các đường dẫn ổn định theo /dev/serial/by-id và /dev/serial/by-path
       12:  162:    const std::vector<std::string> serialDirectories = {"/dev/serial/by-id", "/dev/serial/by-path"};
        -:  163:
       18:  164:    for (const auto& directory : serialDirectories)
        -:  165:    {
      12*:  166:        if (!std::filesystem::exists(directory))
        -:  167:        {
    #####:  168:            continue;
        -:  169:        }
        -:  170:
       30:  171:        for (const auto& entry : std::filesystem::directory_iterator(directory))
        -:  172:        {
      18*:  173:            if (entry.is_symlink() || entry.is_character_file())
        -:  174:            {
       18:  175:                ports.push_back(entry.path().string());
        -:  176:            }
       12:  177:        }
        -:  178:    }
        -:  179:
        -:  180:    // Loại bỏ trùng lặp để tránh thử kết nối nhiều lần
        6:  181:    std::sort(ports.begin(), ports.end());
        6:  182:    ports.erase(std::unique(ports.begin(), ports.end()), ports.end());
        -:  183:
        6:  184:    std::ostringstream portListStream;
        6:  185:    if (ports.empty())
        -:  186:    {
    #####:  187:        portListStream << "none";
        -:  188:    }
        -:  189:    else
        -:  190:    {
       30:  191:        for (size_t index = 0; index < ports.size(); ++index)
        -:  192:        {
       24:  193:            if (index > 0)
        -:  194:            {
       18:  195:                portListStream << ", ";
        -:  196:            }
        -:  197:
       24:  198:            portListStream << ports[index];
        -:  199:        }
        -:  200:    }
        -:  201:    
        6:  202:    LOG_INFO("Found " + std::to_string(ports.size()) + " serial ports: " + portListStream.str());
        -:  203:    
       12:  204:    return ports;
        6:  205:}
        -:  206:
        6:  207:bool HardwareController::connect(const std::string& portName, int baudRate) 
        -:  208:{
        6:  209:    LOG_INFO("Connecting to hardware on port: " + portName + " at " + std::to_string(baudRate) + " baud");
        -:  210:    
        6:  211:    if (m_serialComm->open(portName, baudRate)) 
        -:  212:    {
       12:  213:        LOG_INFO("Hardware connected successfully");
        6:  214:        return true;
        -:  215:    }
        -:  216:    
    #####:  217:    LOG_DEBUG("Failed to connect to hardware on port: " + portName);
    #####:  218:    return false;
        -:  219:}
        -:  220:
       18:  221:void HardwareController::disconnect() 
        -:  222:{
       18:  223:    if (m_serialComm->isOpen()) 
        -:  224:    {
       10:  225:        m_serialComm->close();
       30:  226:        LOG_INFO("Hardware disconnected");
        -:  227:    }
        -:  228:    
        -:  229:    // Clear buffer khi disconnect
       18:  230:    std::lock_guard<std::mutex> lock(m_bufferMutex);
       18:  231:    m_receiveBuffer.clear();
       18:  232:}
        -:  233:
        6:  234:bool HardwareController::isConnected() const 
        -:  235:{
        6:  236:    return m_serialComm->isOpen();
        -:  237:}
        -:  238:
    #####:  239:void HardwareController::refreshConnection()
        -:  240:{
    #####:  241:    if (isConnected())
        -:  242:    {
    #####:  243:        return;
        -:  244:    }
        -:  245:    
        -:  246:    // Don't start a new scan if one is already running
    #####:  247:    if (m_isScanning)
        -:  248:    {
    #####:  249:        return;
        -:  250:    }
        -:  251:
    #####:  252:    const auto now = std::chrono::steady_clock::now();
    #####:  253:    if (now - m_lastReconnectAttempt < m_reconnectInterval)
        -:  254:    {
    #####:  255:        return;
        -:  256:    }
        -:  257:
    #####:  258:    m_lastReconnectAttempt = now;
        -:  259:
        -:  260:    // Trigger async auto connect
    #####:  261:    LOG_DEBUG("Hardware not connected, triggering background reconnect...");
    #####:  262:    autoConnect();
        -:  263:}
        -:  264:
        6:  265:void HardwareController::sendCurrentSongInfo(const std::string& title, const std::string& artist) 
        -:  266:{
        6:  267:    if (!m_serialComm->isOpen()) 
        -:  268:    {
    #####:  269:        return;
        -:  270:    }
        -:  271:    
        -:  272:    // Protocol gửi đi: SONG|title|artist\n
        6:  273:    std::string message = "SONG|" + title + "|" + artist + "\n";
        -:  274:    
        6:  275:    if (m_serialComm->sendData(message)) 
        -:  276:    {
        6:  277:        LOG_DEBUG("Sent song info to hardware: " + title);
        -:  278:    }
        -:  279:    else 
        -:  280:    {
    #####:  281:        LOG_ERROR("Failed to send song info to hardware");
        -:  282:    }
        6:  283:}
        -:  284:
        6:  285:void HardwareController::sendPlaybackState(bool isPlaying) 
        -:  286:{
        6:  287:    if (!m_serialComm->isOpen()) 
        -:  288:    {
    #####:  289:        return;
        -:  290:    }
        -:  291:    
        -:  292:    // Protocol gửi đi: STATE|PLAYING hoặc STATE|PAUSED\n
       6*:  293:    std::string state = isPlaying ? "PLAYING" : "PAUSED";
        6:  294:    std::string message = "STATE|" + state + "\n";
        -:  295:    
        6:  296:    if (m_serialComm->sendData(message)) 
        -:  297:    {
        6:  298:        LOG_DEBUG("Sent playback state to hardware: " + state);
        -:  299:    }
        -:  300:    else 
        -:  301:    {
    #####:  302:        LOG_ERROR("Failed to send playback state to hardware");
        -:  303:    }
        6:  304:}
        -:  305:
    #####:  306:void HardwareController::setButtonCallback(HardwareButtonCallback callback) 
        -:  307:{
    #####:  308:    m_buttonCallback = callback;
    #####:  309:}
        -:  310:
    #####:  311:void HardwareController::setVolumeCallback(HardwareVolumeCallback callback) 
        -:  312:{
    #####:  313:    m_volumeCallback = callback;
    #####:  314:}
        -:  315:
    #####:  316:void HardwareController::onSerialDataReceived(const std::string& data) 
        -:  317:{
        -:  318:    // Log ở mức DEBUG để tránh spam log
    #####:  319:    LOG_DEBUG("Received from hardware: " + data);
        -:  320:    
        -:  321:    // Thêm data vào buffer
        -:  322:    {
    #####:  323:        std::lock_guard<std::mutex> lock(m_bufferMutex);
    #####:  324:        m_receiveBuffer += data;
    #####:  325:    }
        -:  326:    
        -:  327:    // Xử lý buffer để trích xuất các message hoàn chỉnh
    #####:  328:    processBuffer();
    #####:  329:}
        -:  330:
    #####:  331:void HardwareController::processBuffer()
        -:  332:{
    #####:  333:    std::lock_guard<std::mutex> lock(m_bufferMutex);
        -:  334:    
        -:  335:    // Tìm và xử lý các message hoàn chỉnh theo format !...!
    #####:  336:    size_t startPos = 0;
        -:  337:    
    #####:  338:    while (startPos < m_receiveBuffer.length())
        -:  339:    {
        -:  340:        // Tìm vị trí bắt đầu message '!'
    #####:  341:        size_t msgStart = m_receiveBuffer.find('!', startPos);
        -:  342:        
    #####:  343:        if (msgStart == std::string::npos)
        -:  344:        {
        -:  345:            // Không còn message nào, xóa phần đã xử lý
    #####:  346:            m_receiveBuffer.erase(0, startPos);
    #####:  347:            break;
        -:  348:        }
        -:  349:        
        -:  350:        // Tìm vị trí kết thúc message '!' (không phải '!' đầu tiên)
    #####:  351:        size_t msgEnd = m_receiveBuffer.find('!', msgStart + 1);
        -:  352:        
    #####:  353:        if (msgEnd == std::string::npos)
        -:  354:        {
        -:  355:            // Message chưa hoàn chỉnh, giữ lại trong buffer
    #####:  356:            m_receiveBuffer.erase(0, msgStart);
    #####:  357:            break;
        -:  358:        }
        -:  359:        
        -:  360:        // Trích xuất message hoàn chỉnh bao gồm cả 2 dấu '!'
    #####:  361:        std::string completeMessage = m_receiveBuffer.substr(msgStart, msgEnd - msgStart + 1);
        -:  362:        
        -:  363:        // Parse message
    #####:  364:        parseS32K144Message(completeMessage);
        -:  365:        
        -:  366:        // Di chuyển đến sau message vừa xử lý
    #####:  367:        startPos = msgEnd + 1;
    #####:  368:    }
        -:  369:    
        -:  370:    // Xóa phần đã xử lý
    #####:  371:    if (startPos > 0 && startPos <= m_receiveBuffer.length())
        -:  372:    {
    #####:  373:        m_receiveBuffer.erase(0, startPos);
        -:  374:    }
        -:  375:    
        -:  376:    // Giới hạn kích thước buffer để tránh memory leak
    #####:  377:    const size_t MAX_BUFFER_SIZE = 1024;
    #####:  378:    if (m_receiveBuffer.length() > MAX_BUFFER_SIZE)
        -:  379:    {
    #####:  380:        LOG_WARNING("Buffer overflow, clearing...");
    #####:  381:        m_receiveBuffer.clear();
        -:  382:    }
    #####:  383:}
        -:  384:
    #####:  385:bool HardwareController::parseS32K144Message(const std::string& message)
        -:  386:{
    #####:  387:    std::smatch match;
        -:  388:    
        -:  389:    // Parse ADC message: "!ADC:%d!" - điều chỉnh volume
    #####:  390:    if (std::regex_match(message, match, ADC_PATTERN))
        -:  391:    {
        -:  392:        try
        -:  393:        {
    #####:  394:            int volume = std::stoi(match[1].str());
        -:  395:            
        -:  396:            // Validate volume từ 0-100, loại bỏ message ngoài range
    #####:  397:            if (volume < ADC_MIN_VALUE || volume > ADC_MAX_VALUE)
        -:  398:            {
    #####:  399:                LOG_WARNING("ADC value out of range: " + std::to_string(volume));
    #####:  400:                return false;
        -:  401:            }
        -:  402:            
    #####:  403:            LOG_INFO("S32K144 ADC Volume: " + std::to_string(volume));
        -:  404:            
    #####:  405:            if (m_volumeCallback)
        -:  406:            {
    #####:  407:                m_volumeCallback(volume);
        -:  408:            }
        -:  409:            
    #####:  410:            return true;
        -:  411:        }
    =====:  412:        catch (const std::exception& e)
        -:  413:        {
    =====:  414:            LOG_ERROR("Failed to parse ADC value: " + message);
    =====:  415:        }
        -:  416:    }
        -:  417:    
        -:  418:    // Parse BTN message: "!BTN:%d!" - điều khiển playback
    #####:  419:    if (std::regex_match(message, match, BTN_PATTERN))
        -:  420:    {
        -:  421:        try
        -:  422:        {
    #####:  423:            int buttonId = std::stoi(match[1].str());
        -:  424:            
        -:  425:            // Validate button ID từ 1-4
    #####:  426:            if (buttonId >= BTN_MIN_VALUE && buttonId <= BTN_MAX_VALUE)
        -:  427:            {
    #####:  428:                HardwareButton button = static_cast<HardwareButton>(buttonId);
        -:  429:                
    #####:  430:                LOG_INFO("S32K144 Button pressed: " + std::to_string(buttonId));
        -:  431:                
    #####:  432:                if (m_buttonCallback)
        -:  433:                {
    #####:  434:                    m_buttonCallback(button);
        -:  435:                }
        -:  436:                
    #####:  437:                return true;
        -:  438:            }
        -:  439:            else
        -:  440:            {
    #####:  441:                LOG_WARNING("Invalid button ID: " + std::to_string(buttonId));
        -:  442:            }
        -:  443:        }
    =====:  444:        catch (const std::exception& e)
        -:  445:        {
    =====:  446:            LOG_ERROR("Failed to parse BTN value: " + message);
    =====:  447:        }
        -:  448:    }
        -:  449:    
    #####:  450:    LOG_DEBUG("Unknown S32K144 message format: " + message);
    #####:  451:    return false;
    #####:  452:}
        -:  453:
        -:  454:} // namespace controllers
        -:  455:} // namespace media_player
