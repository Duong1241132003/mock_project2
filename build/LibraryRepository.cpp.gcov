        -:    0:Source:/home/duong/MediaPlayerApp/src/repositories/LibraryRepository.cpp
        -:    0:Graph:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/repositories/LibraryRepository.cpp.gcno
        -:    0:Data:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/repositories/LibraryRepository.cpp.gcda
        -:    0:Runs:6
        -:    1:// Project includes
        -:    2:#include "repositories/LibraryRepository.h"
        -:    3:#include "utils/Logger.h"
        -:    4:
        -:    5:// System includes
        -:    6:#include <fstream>
        -:    7:#include <filesystem>
        -:    8:#include <sstream>
        -:    9:#include <algorithm>
        -:   10:
        -:   11:namespace fs = std::filesystem;
        -:   12:
        -:   13:namespace media_player 
        -:   14:{
        -:   15:namespace repositories 
        -:   16:{
        -:   17:
    #####:   18:LibraryRepository::LibraryRepository(const std::string& storagePath)
    #####:   19:    : m_storagePath(storagePath)
        -:   20:{
    #####:   21:    ensureStorageDirectoryExists();
    #####:   22:    loadFromDisk();
        -:   23:    
    #####:   24:    LOG_INFO("LibraryRepository initialized with storage path: " + storagePath);
    #####:   25:}
        -:   26:
    #####:   27:LibraryRepository::~LibraryRepository() 
        -:   28:{
    #####:   29:    saveToDisk();
    #####:   30:    LOG_INFO("LibraryRepository destroyed");
    #####:   31:}
------------------
_ZN12media_player12repositories17LibraryRepositoryD0Ev:
    #####:   27:LibraryRepository::~LibraryRepository() 
        -:   28:{
        -:   29:    saveToDisk();
        -:   30:    LOG_INFO("LibraryRepository destroyed");
    #####:   31:}
------------------
_ZN12media_player12repositories17LibraryRepositoryD2Ev:
    #####:   27:LibraryRepository::~LibraryRepository() 
        -:   28:{
    #####:   29:    saveToDisk();
    #####:   30:    LOG_INFO("LibraryRepository destroyed");
    #####:   31:}
------------------
        -:   32:
    #####:   33:bool LibraryRepository::save(const models::MediaFileModel& media) 
        -:   34:{
    #####:   35:    std::lock_guard<std::mutex> lock(m_mutex);
        -:   36:    
    #####:   37:    std::string id = generateId(media.getFilePath());
    #####:   38:    m_cache[id] = media;
        -:   39:    
    #####:   40:    LOG_DEBUG("Media saved to library: " + media.getFileName());
    #####:   41:    return true;
    #####:   42:}
        -:   43:
    #####:   44:std::optional<models::MediaFileModel> LibraryRepository::findById(const std::string& id) 
        -:   45:{
    #####:   46:    std::lock_guard<std::mutex> lock(m_mutex);
        -:   47:    
    #####:   48:    auto it = m_cache.find(id);
        -:   49:    
    #####:   50:    if (it != m_cache.end()) 
        -:   51:    {
    #####:   52:        return it->second;
        -:   53:    }
        -:   54:    
    #####:   55:    return std::nullopt;
    #####:   56:}
        -:   57:
    #####:   58:std::vector<models::MediaFileModel> LibraryRepository::findAll() 
        -:   59:{
    #####:   60:    std::lock_guard<std::mutex> lock(m_mutex);
        -:   61:    
    #####:   62:    std::vector<models::MediaFileModel> result;
    #####:   63:    result.reserve(m_cache.size());
        -:   64:    
    #####:   65:    for (const auto& pair : m_cache) 
        -:   66:    {
    #####:   67:        result.push_back(pair.second);
        -:   68:    }
        -:   69:    
    #####:   70:    return result;
    #####:   71:}
        -:   72:
    #####:   73:bool LibraryRepository::update(const models::MediaFileModel& media) 
        -:   74:{
    #####:   75:    std::lock_guard<std::mutex> lock(m_mutex);
        -:   76:    
    #####:   77:    std::string id = generateId(media.getFilePath());
        -:   78:    
    #####:   79:    if (m_cache.find(id) == m_cache.end()) 
        -:   80:    {
    #####:   81:        LOG_WARNING("Cannot update non-existent media: " + media.getFilePath());
    #####:   82:        return false;
        -:   83:    }
        -:   84:    
    #####:   85:    m_cache[id] = media;
    #####:   86:    LOG_DEBUG("Media updated in library: " + media.getFileName());
        -:   87:    
    #####:   88:    return true;
    #####:   89:}
        -:   90:
    #####:   91:bool LibraryRepository::remove(const std::string& id) 
        -:   92:{
    #####:   93:    std::lock_guard<std::mutex> lock(m_mutex);
        -:   94:    
    #####:   95:    auto it = m_cache.find(id);
        -:   96:    
    #####:   97:    if (it == m_cache.end()) 
        -:   98:    {
    #####:   99:        return false;
        -:  100:    }
        -:  101:    
    #####:  102:    std::string fileName = it->second.getFileName();
    #####:  103:    m_cache.erase(it);
        -:  104:    
    #####:  105:    LOG_DEBUG("Media removed from library: " + fileName);
    #####:  106:    return true;
    #####:  107:}
        -:  108:
    #####:  109:bool LibraryRepository::exists(const std::string& id) 
        -:  110:{
    #####:  111:    std::lock_guard<std::mutex> lock(m_mutex);
    #####:  112:    return m_cache.find(id) != m_cache.end();
    #####:  113:}
        -:  114:
    #####:  115:bool LibraryRepository::saveAll(const std::vector<models::MediaFileModel>& mediaList) 
        -:  116:{
    #####:  117:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  118:    
    #####:  119:    for (const auto& media : mediaList) 
        -:  120:    {
    #####:  121:        std::string id = generateId(media.getFilePath());
    #####:  122:        m_cache[id] = media;
    #####:  123:    }
        -:  124:    
    #####:  125:    LOG_INFO("Saved " + std::to_string(mediaList.size()) + " media files to library");
    #####:  126:    return true;
    #####:  127:}
        -:  128:
    #####:  129:void LibraryRepository::clear() 
        -:  130:{
    #####:  131:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  132:    
    #####:  133:    m_cache.clear();
    #####:  134:    LOG_INFO("Library cleared");
    #####:  135:}
        -:  136:
    #####:  137:size_t LibraryRepository::count() const 
        -:  138:{
    #####:  139:    std::lock_guard<std::mutex> lock(m_mutex);
    #####:  140:    return m_cache.size();
    #####:  141:}
        -:  142:
    #####:  143:std::optional<models::MediaFileModel> LibraryRepository::findByPath(const std::string& filePath) 
        -:  144:{
    #####:  145:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  146:    
    #####:  147:    std::string id = generateId(filePath);
    #####:  148:    return findById(id);
    #####:  149:}
        -:  150:
    #####:  151:std::vector<models::MediaFileModel> LibraryRepository::findByType(models::MediaType type) 
        -:  152:{
    #####:  153:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  154:    
    #####:  155:    std::vector<models::MediaFileModel> result;
        -:  156:    
    #####:  157:    for (const auto& pair : m_cache) 
        -:  158:    {
    #####:  159:        if (pair.second.getType() == type) 
        -:  160:        {
    #####:  161:            result.push_back(pair.second);
        -:  162:        }
        -:  163:    }
        -:  164:    
    #####:  165:    return result;
    #####:  166:}
        -:  167:
    #####:  168:std::vector<models::MediaFileModel> LibraryRepository::searchByFileName(const std::string& query) 
        -:  169:{
    #####:  170:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  171:    
    #####:  172:    std::vector<models::MediaFileModel> results;
    #####:  173:    std::string lowerQuery = query;
    #####:  174:    std::transform(lowerQuery.begin(), lowerQuery.end(), lowerQuery.begin(), ::tolower);
        -:  175:    
    #####:  176:    for (const auto& pair : m_cache) 
        -:  177:    {
    #####:  178:        std::string lowerName = pair.second.getFileName();
    #####:  179:        std::transform(lowerName.begin(), lowerName.end(), lowerName.begin(), ::tolower);
        -:  180:        
    #####:  181:        if (lowerName.find(lowerQuery) != std::string::npos) 
        -:  182:        {
    #####:  183:            results.push_back(pair.second);
        -:  184:        }
    #####:  185:    }
        -:  186:    
    #####:  187:    return results;
    #####:  188:}
        -:  189:
    #####:  190:size_t LibraryRepository::countByType(models::MediaType type) const 
        -:  191:{
    #####:  192:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  193:    
    #####:  194:    size_t count = 0;
        -:  195:    
    #####:  196:    for (const auto& pair : m_cache) 
        -:  197:    {
    #####:  198:        if (pair.second.getType() == type) 
        -:  199:        {
    #####:  200:            count++;
        -:  201:        }
        -:  202:    }
        -:  203:    
    #####:  204:    return count;
    #####:  205:}
        -:  206:
    #####:  207:long long LibraryRepository::getTotalSize() const 
        -:  208:{
    #####:  209:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  210:    
    #####:  211:    long long totalSize = 0;
        -:  212:    
    #####:  213:    for (const auto& pair : m_cache) 
        -:  214:    {
    #####:  215:        totalSize += pair.second.getFileSize();
        -:  216:    }
        -:  217:    
    #####:  218:    return totalSize;
    #####:  219:}
        -:  220:
    #####:  221:bool LibraryRepository::loadFromDisk() 
        -:  222:{
    #####:  223:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  224:    
    #####:  225:    return deserializeLibrary();
    #####:  226:}
        -:  227:
    #####:  228:bool LibraryRepository::saveToDisk() 
        -:  229:{
    #####:  230:    std::lock_guard<std::mutex> lock(m_mutex);
        -:  231:    
    #####:  232:    return serializeLibrary();
    #####:  233:}
        -:  234:
    #####:  235:std::string LibraryRepository::getLibraryFilePath() const 
        -:  236:{
    #####:  237:    return m_storagePath + "/library.dat";
        -:  238:}
        -:  239:
    #####:  240:bool LibraryRepository::serializeLibrary() 
        -:  241:{
        -:  242:    try 
        -:  243:    {
    #####:  244:        std::string filePath = getLibraryFilePath();
    #####:  245:        std::ofstream file(filePath);
        -:  246:        
    #####:  247:        if (!file.is_open()) 
        -:  248:        {
    #####:  249:            LOG_ERROR("Failed to open library file for writing: " + filePath);
    #####:  250:            return false;
        -:  251:        }
        -:  252:        
    #####:  253:        file << "LIBRARY_VERSION:1.0\n";
    #####:  254:        file << "COUNT:" << m_cache.size() << "\n";
    #####:  255:        file << "ENTRIES:\n";
        -:  256:        
    #####:  257:        for (const auto& pair : m_cache) 
        -:  258:        {
    #####:  259:            const auto& media = pair.second;
    #####:  260:            file << media.getFilePath() << "|"
    #####:  261:                 << media.getFileName() << "|"
    #####:  262:                 << media.getExtension() << "|"
    #####:  263:                 << static_cast<int>(media.getType()) << "|"
    #####:  264:                 << media.getFileSize() << "\n";
        -:  265:        }
        -:  266:        
    #####:  267:        file.close();
    #####:  268:        LOG_INFO("Library serialized successfully");
        -:  269:        
    #####:  270:        return true;
    #####:  271:    }
    =====:  272:    catch (const std::exception& e) 
        -:  273:    {
    =====:  274:        LOG_ERROR("Exception serializing library: " + std::string(e.what()));
    =====:  275:        return false;
    =====:  276:    }
        -:  277:}
        -:  278:
    #####:  279:bool LibraryRepository::deserializeLibrary() 
        -:  280:{
        -:  281:    try 
        -:  282:    {
    #####:  283:        std::string filePath = getLibraryFilePath();
        -:  284:        
    #####:  285:        if (!fs::exists(filePath)) 
        -:  286:        {
    #####:  287:            LOG_INFO("Library file does not exist, starting with empty library");
    #####:  288:            return true;
        -:  289:        }
        -:  290:        
    #####:  291:        std::ifstream file(filePath);
        -:  292:        
    #####:  293:        if (!file.is_open()) 
        -:  294:        {
    #####:  295:            LOG_ERROR("Failed to open library file for reading: " + filePath);
    #####:  296:            return false;
        -:  297:        }
        -:  298:        
    #####:  299:        std::string line;
    #####:  300:        bool readingEntries = false;
    #####:  301:        int loadedCount = 0;
        -:  302:        
    #####:  303:        while (std::getline(file, line)) 
        -:  304:        {
    #####:  305:            if (line.empty()) 
        -:  306:            {
    #####:  307:                continue;
        -:  308:            }
        -:  309:            
    #####:  310:            if (line == "ENTRIES:") 
        -:  311:            {
    #####:  312:                readingEntries = true;
    #####:  313:                continue;
        -:  314:            }
        -:  315:            
    #####:  316:            if (readingEntries) 
        -:  317:            {
        -:  318:                // Parse entry: filepath|filename|extension|type|size
    #####:  319:                std::istringstream iss(line);
    #####:  320:                std::string filePath;
        -:  321:                
    #####:  322:                if (std::getline(iss, filePath, '|')) 
        -:  323:                {
    #####:  324:                    models::MediaFileModel media(filePath);
        -:  325:                    
    #####:  326:                    if (media.isValid()) 
        -:  327:                    {
    #####:  328:                        std::string id = generateId(filePath);
    #####:  329:                        m_cache[id] = media;
    #####:  330:                        loadedCount++;
    #####:  331:                    }
    #####:  332:                }
    #####:  333:            }
        -:  334:        }
        -:  335:        
    #####:  336:        file.close();
    #####:  337:        LOG_INFO("Loaded " + std::to_string(loadedCount) + " media files from library");
        -:  338:        
    #####:  339:        return true;
    #####:  340:    }
    =====:  341:    catch (const std::exception& e) 
        -:  342:    {
    =====:  343:        LOG_ERROR("Exception deserializing library: " + std::string(e.what()));
    =====:  344:        return false;
    =====:  345:    }
        -:  346:}
        -:  347:
    #####:  348:void LibraryRepository::ensureStorageDirectoryExists() 
        -:  349:{
        -:  350:    try 
        -:  351:    {
    #####:  352:        if (!fs::exists(m_storagePath)) 
        -:  353:        {
    #####:  354:            fs::create_directories(m_storagePath);
    #####:  355:            LOG_INFO("Created storage directory: " + m_storagePath);
        -:  356:        }
        -:  357:    }
    =====:  358:    catch (const fs::filesystem_error& e) 
        -:  359:    {
    =====:  360:        LOG_ERROR("Failed to create storage directory: " + std::string(e.what()));
    =====:  361:    }
    #####:  362:}
        -:  363:
    #####:  364:std::string LibraryRepository::generateId(const std::string& filePath) const 
        -:  365:{
        -:  366:    // Simple hash-based ID generation
        -:  367:    std::hash<std::string> hasher;
    #####:  368:    size_t hash = hasher(filePath);
        -:  369:    
    #####:  370:    return "media_" + std::to_string(hash);
        -:  371:}
        -:  372:
        -:  373:} // namespace repositories
        -:  374:} // namespace media_player
