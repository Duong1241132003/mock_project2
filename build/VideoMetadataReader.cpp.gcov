        -:    0:Source:/home/duong/MediaPlayerApp/src/services/VideoMetadataReader.cpp
        -:    0:Graph:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/services/VideoMetadataReader.cpp.gcno
        -:    0:Data:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/services/VideoMetadataReader.cpp.gcda
        -:    0:Runs:6
        -:    1:// Project includes
        -:    2:#include "services/VideoMetadataReader.h"
        -:    3:#include "utils/Logger.h"
        -:    4:#include "config/AppConfig.h"
        -:    5:
        -:    6:// FFmpeg includes
        -:    7:extern "C" 
        -:    8:{
        -:    9:#include <libavformat/avformat.h>
        -:   10:#include <libavcodec/avcodec.h>
        -:   11:#include <libavutil/imgutils.h>
        -:   12:#include <libswscale/swscale.h>
        -:   13:}
        -:   14:
        -:   15:// System includes
        -:   16:#include <algorithm>
        -:   17:
        -:   18:namespace media_player 
        -:   19:{
        -:   20:namespace services 
        -:   21:{
        -:   22:
    #####:   23:VideoMetadataReader::VideoMetadataReader() 
        -:   24:{
    #####:   25:    LOG_INFO("VideoMetadataReader initialized");
    #####:   26:}
        -:   27:
    #####:   28:VideoMetadataReader::~VideoMetadataReader() 
        -:   29:{
    #####:   30:    LOG_INFO("VideoMetadataReader destroyed");
    #####:   31:}
------------------
_ZN12media_player8services19VideoMetadataReaderD0Ev:
    #####:   28:VideoMetadataReader::~VideoMetadataReader() 
        -:   29:{
        -:   30:    LOG_INFO("VideoMetadataReader destroyed");
    #####:   31:}
------------------
_ZN12media_player8services19VideoMetadataReaderD2Ev:
    #####:   28:VideoMetadataReader::~VideoMetadataReader() 
        -:   29:{
    #####:   30:    LOG_INFO("VideoMetadataReader destroyed");
    #####:   31:}
------------------
        -:   32:
    #####:   33:std::unique_ptr<models::VideoMetadataModel> VideoMetadataReader::readMetadata(const std::string& filePath) 
        -:   34:{
    #####:   35:    if (!canReadFile(filePath)) 
        -:   36:    {
    #####:   37:        LOG_ERROR("Cannot read video file: " + filePath);
    #####:   38:        return nullptr;
        -:   39:    }
        -:   40:    
    #####:   41:    auto metadata = std::make_unique<models::VideoMetadataModel>();
        -:   42:    
    #####:   43:    AVFormatContext* formatContext = nullptr;
        -:   44:    
    #####:   45:    if (avformat_open_input(&formatContext, filePath.c_str(), nullptr, nullptr) != 0) 
        -:   46:    {
    #####:   47:        LOG_ERROR("Could not open video file: " + filePath);
    #####:   48:        return nullptr;
        -:   49:    }
        -:   50:    
    #####:   51:    if (avformat_find_stream_info(formatContext, nullptr) < 0) 
        -:   52:    {
    #####:   53:        LOG_ERROR("Could not find stream info: " + filePath);
    #####:   54:        avformat_close_input(&formatContext);
    #####:   55:        return nullptr;
        -:   56:    }
        -:   57:    
        -:   58:    // Find video and audio streams
    #####:   59:    int videoStreamIndex = -1;
    #####:   60:    int audioStreamIndex = -1;
        -:   61:    
    #####:   62:    for (unsigned int i = 0; i < formatContext->nb_streams; i++) 
        -:   63:    {
    #####:   64:        AVCodecParameters* codecParams = formatContext->streams[i]->codecpar;
        -:   65:        
    #####:   66:        if (codecParams->codec_type == AVMEDIA_TYPE_VIDEO && videoStreamIndex == -1) 
        -:   67:        {
    #####:   68:            videoStreamIndex = i;
        -:   69:        }
    #####:   70:        else if (codecParams->codec_type == AVMEDIA_TYPE_AUDIO && audioStreamIndex == -1) 
        -:   71:        {
    #####:   72:            audioStreamIndex = i;
        -:   73:        }
        -:   74:    }
        -:   75:    
    #####:   76:    if (videoStreamIndex == -1) 
        -:   77:    {
    #####:   78:        LOG_ERROR("No video stream found in file: " + filePath);
    #####:   79:        avformat_close_input(&formatContext);
    #####:   80:        return nullptr;
        -:   81:    }
        -:   82:    
        -:   83:    // Extract video metadata
    #####:   84:    AVStream* videoStream = formatContext->streams[videoStreamIndex];
    #####:   85:    AVCodecParameters* videoCodecParams = videoStream->codecpar;
        -:   86:    
    #####:   87:    metadata->setResolution(videoCodecParams->width, videoCodecParams->height);
        -:   88:    
        -:   89:    // Frame rate
    #####:   90:    AVRational frameRate = videoStream->avg_frame_rate;
    #####:   91:    if (frameRate.den != 0) 
        -:   92:    {
    #####:   93:        double fps = static_cast<double>(frameRate.num) / static_cast<double>(frameRate.den);
    #####:   94:        metadata->setFrameRate(fps);
        -:   95:    }
        -:   96:    
        -:   97:    // Duration
    #####:   98:    if (formatContext->duration != AV_NOPTS_VALUE) 
        -:   99:    {
    #####:  100:        int durationSeconds = formatContext->duration / AV_TIME_BASE;
    #####:  101:        metadata->setDuration(durationSeconds);
        -:  102:    }
        -:  103:    
        -:  104:    // Bitrate
    #####:  105:    if (formatContext->bit_rate > 0) 
        -:  106:    {
    #####:  107:        metadata->setBitrate(formatContext->bit_rate);
        -:  108:    }
        -:  109:    
        -:  110:    // Video codec
    #####:  111:    const AVCodec* videoCodec = avcodec_find_decoder(videoCodecParams->codec_id);
    #####:  112:    if (videoCodec) 
        -:  113:    {
    #####:  114:        metadata->setVideoCodec(videoCodec->name);
        -:  115:    }
        -:  116:    
        -:  117:    // Extract audio metadata if available
    #####:  118:    if (audioStreamIndex != -1) 
        -:  119:    {
    #####:  120:        AVCodecParameters* audioCodecParams = formatContext->streams[audioStreamIndex]->codecpar;
        -:  121:        
    #####:  122:        const AVCodec* audioCodec = avcodec_find_decoder(audioCodecParams->codec_id);
    #####:  123:        if (audioCodec) 
        -:  124:        {
    #####:  125:            metadata->setAudioCodec(audioCodec->name);
        -:  126:        }
        -:  127:        
    #####:  128:        metadata->setAudioChannels(audioCodecParams->channels);
    #####:  129:        metadata->setAudioSampleRate(audioCodecParams->sample_rate);
        -:  130:    }
        -:  131:    
        -:  132:    // Title from metadata
    #####:  133:    AVDictionaryEntry* titleEntry = av_dict_get(formatContext->metadata, "title", nullptr, 0);
    #####:  134:    if (titleEntry) 
        -:  135:    {
    #####:  136:        metadata->setTitle(titleEntry->value);
        -:  137:    }
        -:  138:    
    #####:  139:    avformat_close_input(&formatContext);
        -:  140:    
    #####:  141:    LOG_INFO("Successfully read video metadata from: " + filePath);
    #####:  142:    return metadata;
    #####:  143:}
        -:  144:
    #####:  145:bool VideoMetadataReader::canReadFile(const std::string& filePath) const 
        -:  146:{
    #####:  147:    return isSupportedFormat(filePath);
        -:  148:}
        -:  149:
    #####:  150:bool VideoMetadataReader::extractThumbnail(const std::string& filePath, 
        -:  151:                                          const std::string& outputPath, 
        -:  152:                                          int timeSeconds) 
        -:  153:{
    #####:  154:    AVFormatContext* formatContext = nullptr;
        -:  155:    
    #####:  156:    if (avformat_open_input(&formatContext, filePath.c_str(), nullptr, nullptr) != 0) 
        -:  157:    {
    #####:  158:        LOG_ERROR("Could not open video file for thumbnail: " + filePath);
    #####:  159:        return false;
        -:  160:    }
        -:  161:    
    #####:  162:    if (avformat_find_stream_info(formatContext, nullptr) < 0) 
        -:  163:    {
    #####:  164:        avformat_close_input(&formatContext);
    #####:  165:        return false;
        -:  166:    }
        -:  167:    
    #####:  168:    int videoStreamIndex = -1;
    #####:  169:    for (unsigned int i = 0; i < formatContext->nb_streams; i++) 
        -:  170:    {
    #####:  171:        if (formatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) 
        -:  172:        {
    #####:  173:            videoStreamIndex = i;
    #####:  174:            break;
        -:  175:        }
        -:  176:    }
        -:  177:    
    #####:  178:    if (videoStreamIndex == -1) 
        -:  179:    {
    #####:  180:        avformat_close_input(&formatContext);
    #####:  181:        return false;
        -:  182:    }
        -:  183:    
    #####:  184:    AVStream* videoStream = formatContext->streams[videoStreamIndex];
    #####:  185:    AVCodecParameters* codecParams = videoStream->codecpar;
        -:  186:    
    #####:  187:    const AVCodec* codec = avcodec_find_decoder(codecParams->codec_id);
    #####:  188:    if (!codec) 
        -:  189:    {
    #####:  190:        avformat_close_input(&formatContext);
    #####:  191:        return false;
        -:  192:    }
        -:  193:    
    #####:  194:    AVCodecContext* codecContext = avcodec_alloc_context3(codec);
    #####:  195:    avcodec_parameters_to_context(codecContext, codecParams);
        -:  196:    
    #####:  197:    if (avcodec_open2(codecContext, codec, nullptr) < 0) 
        -:  198:    {
    #####:  199:        avcodec_free_context(&codecContext);
    #####:  200:        avformat_close_input(&formatContext);
    #####:  201:        return false;
        -:  202:    }
        -:  203:    
        -:  204:    // Seek to desired time
    #####:  205:    int64_t timestamp = timeSeconds * AV_TIME_BASE;
    #####:  206:    av_seek_frame(formatContext, -1, timestamp, AVSEEK_FLAG_BACKWARD);
        -:  207:    
    #####:  208:    AVPacket* packet = av_packet_alloc();
    #####:  209:    AVFrame* frame = av_frame_alloc();
        -:  210:    
    #####:  211:    bool thumbnailExtracted = false;
        -:  212:    
    #####:  213:    while (av_read_frame(formatContext, packet) >= 0) 
        -:  214:    {
    #####:  215:        if (packet->stream_index == videoStreamIndex) 
        -:  216:        {
    #####:  217:            if (avcodec_send_packet(codecContext, packet) == 0) 
        -:  218:            {
    #####:  219:                if (avcodec_receive_frame(codecContext, frame) == 0) 
        -:  220:                {
        -:  221:                    // Frame extracted - save as image (simplified)
        -:  222:                    // In real implementation, use libpng or libjpeg to save
    #####:  223:                    LOG_INFO("Thumbnail frame extracted (saving not implemented)");
    #####:  224:                    thumbnailExtracted = true;
    #####:  225:                    break;
        -:  226:                }
        -:  227:            }
        -:  228:        }
    #####:  229:        av_packet_unref(packet);
        -:  230:    }
        -:  231:    
    #####:  232:    av_frame_free(&frame);
    #####:  233:    av_packet_free(&packet);
    #####:  234:    avcodec_free_context(&codecContext);
    #####:  235:    avformat_close_input(&formatContext);
        -:  236:    
    #####:  237:    return thumbnailExtracted;
        -:  238:}
        -:  239:
    #####:  240:bool VideoMetadataReader::isSupportedFormat(const std::string& filePath) const 
        -:  241:{
    #####:  242:    std::string extension = getFileExtension(filePath);
    #####:  243:    const auto& videoExts = config::AppConfig::SUPPORTED_VIDEO_EXTENSIONS;
        -:  244:    
    #####:  245:    return std::find(videoExts.begin(), videoExts.end(), extension) != videoExts.end();
    #####:  246:}
        -:  247:
    #####:  248:std::string VideoMetadataReader::getFileExtension(const std::string& filePath) const 
        -:  249:{
    #####:  250:    size_t dotPos = filePath.find_last_of('.');
        -:  251:    
    #####:  252:    if (dotPos == std::string::npos) 
        -:  253:    {
    #####:  254:        return "";
        -:  255:    }
        -:  256:    
    #####:  257:    std::string extension = filePath.substr(dotPos);
    #####:  258:    std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);
        -:  259:    
    #####:  260:    return extension;
    #####:  261:}
        -:  262:
        -:  263:} // namespace services
        -:  264:} // namespace media_player
