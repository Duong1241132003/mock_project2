        -:    0:Source:/home/duong/MediaPlayerApp/src/ui/ImGuiManager.cpp
        -:    0:Graph:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/ui/ImGuiManager.cpp.gcno
        -:    0:Data:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/ui/ImGuiManager.cpp.gcda
        -:    0:Runs:6
        -:    1:// Project includes
        -:    2:#include "ui/ImGuiManager.h"
        -:    3:#include "utils/Logger.h"
        -:    4:#include "models/MediaFileModel.h"
        -:    5:#include "controllers/PlaybackController.h"
        -:    6:#include "controllers/QueueController.h"
        -:    7:#include "controllers/LibraryController.h"
        -:    8:#include "controllers/PlaylistController.h"
        -:    9:#include "models/PlaylistModel.h"
        -:   10:
        -:   11:// SDL includes
        -:   12:#include <SDL2/SDL_ttf.h>
        -:   13:
        -:   14:// System includes
        -:   15:#include <sstream>
        -:   16:#include <iomanip>
        -:   17:#include <algorithm>
        -:   18:#include <cmath>
        -:   19:#include <fstream>
        -:   20:#include <chrono>
        -:   21:#include <filesystem>
        -:   22:
        -:   23:namespace media_player 
        -:   24:{
        -:   25:namespace ui 
        -:   26:{
        -:   27:
        -:   28:// Helper to extract RGBA from packed color
    #####:   29:static void unpackColor(uint32_t color, Uint8& r, Uint8& g, Uint8& b, Uint8& a) {
    #####:   30:    a = (color >> 24) & 0xFF;
    #####:   31:    r = (color >> 16) & 0xFF;
    #####:   32:    g = (color >> 8) & 0xFF;
    #####:   33:    b = color & 0xFF;
    #####:   34:}
        -:   35:
    #####:   36:Theme Theme::light() {
    #####:   37:    Theme t;
        -:   38:    // Modern Light Theme
    #####:   39:    t.background      = 0xFFF5F6FA;  // Very soft gray/white background (Lynx White)
    #####:   40:    t.surface         = 0xFFFFFFFF;  // Pure white cards/panels
    #####:   41:    t.surfaceHover    = 0xFFE8EAF6;  // Very light indigo tint for hover
    #####:   42:    t.surfaceActive   = 0xFFDCE1E8;  // Light gray-blue active
        -:   43:    
        -:   44:    // Primary - use a vibrant but professional blue (similar to iOS/macOS blue)
    #####:   45:    t.primary         = 0xFF007AFF;  
    #####:   46:    t.primaryHover    = 0xFF3395FF;
    #####:   47:    t.primaryActive   = 0xFF0056B3;
        -:   48:    
        -:   49:    // Text - High contrast dark gray (not full black for softness)
    #####:   50:    t.textPrimary     = 0xFF2C3E50;  // Dark Blue-Gray (Midnight Blue)
    #####:   51:    t.textSecondary   = 0xFF7F8C8D;  // Medium Gray (Asbestos)
    #####:   52:    t.textDim         = 0xFF95A5A6;  // Light Gray (Concrete)
        -:   53:    
        -:   54:    // Status
    #####:   55:    t.success         = 0xFF2ECC71;  // Emerald Green
    #####:   56:    t.warning         = 0xFFF1C40F;  // Sun Flower Yellow
    #####:   57:    t.error           = 0xFFE74C3C;  // Alizarin Red
        -:   58:    
        -:   59:    // UI Elements
    #####:   60:    t.border          = 0xFFDCDCDC;  // Light gray border
    #####:   61:    t.scrollbar       = 0xFFF0F0F0;
    #####:   62:    t.scrollbarThumb  = 0xFFBDC3C7;
        -:   63:    
    #####:   64:    return t;
        -:   65:}
        -:   66:
    #####:   67:ImGuiManager::ImGuiManager() {
        -:   68:    // Set default theme to Light
    #####:   69:    m_theme = Theme::light();
    #####:   70:}
        -:   71:
    #####:   72:ImGuiManager::~ImGuiManager() {
    #####:   73:    shutdown();
    #####:   74:}
        -:   75:
    #####:   76:bool ImGuiManager::initialize(const std::string& title, int width, int height) {
    #####:   77:    m_width = width;
    #####:   78:    m_height = height;
        -:   79:    
        -:   80:    // Initialize SDL_ttf
    #####:   81:    if (TTF_Init() < 0) {
    #####:   82:        LOG_ERROR("Failed to initialize SDL_ttf: " + std::string(TTF_GetError()));
    #####:   83:        return false;
        -:   84:    }
        -:   85:    
        -:   86:    // Create window with OpenGL context for better rendering
    #####:   87:    m_window = SDL_CreateWindow(
        -:   88:        title.c_str(),
        -:   89:        SDL_WINDOWPOS_CENTERED,
        -:   90:        SDL_WINDOWPOS_CENTERED,
        -:   91:        width,
        -:   92:        height,
        -:   93:        SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI
        -:   94:    );
        -:   95:    
    #####:   96:    if (!m_window) {
    #####:   97:        LOG_ERROR("Failed to create window: " + std::string(SDL_GetError()));
    #####:   98:        return false;
        -:   99:    }
        -:  100:    
        -:  101:    // Create hardware-accelerated renderer
    #####:  102:    m_renderer = SDL_CreateRenderer(
        -:  103:        m_window,
        -:  104:        -1,
        -:  105:        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC
        -:  106:    );
        -:  107:    
    #####:  108:    if (!m_renderer) {
    #####:  109:        LOG_ERROR("Failed to create renderer: " + std::string(SDL_GetError()));
    #####:  110:        return false;
        -:  111:    }
        -:  112:    
        -:  113:    // Enable alpha blending
    #####:  114:    SDL_SetRenderDrawBlendMode(m_renderer, SDL_BLENDMODE_BLEND);
        -:  115:    
        -:  116:    // Load fonts
    #####:  117:    const char* fontPaths[] = {
        -:  118:        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        -:  119:        "/usr/share/fonts/truetype/freefont/FreeSans.ttf",
        -:  120:        "/usr/share/fonts/TTF/DejaVuSans.ttf",
        -:  121:        "/usr/share/fonts/liberation/LiberationSans-Regular.ttf",
        -:  122:        "/usr/share/fonts/noto/NotoSans-Regular.ttf"
        -:  123:    };
        -:  124:    
    #####:  125:    for (const char* path : fontPaths) {
    #####:  126:        m_font = TTF_OpenFont(path, 14);
    #####:  127:        if (m_font) {
    #####:  128:            m_fontLarge = TTF_OpenFont(path, 20);
    #####:  129:            m_fontSmall = TTF_OpenFont(path, 11);
    #####:  130:            LOG_INFO("Loaded font: " + std::string(path));
    #####:  131:            break;
        -:  132:        }
        -:  133:    }
        -:  134:    
    #####:  135:    if (!m_font) {
    #####:  136:        LOG_WARNING("No system font found, text rendering will be limited");
        -:  137:    }
        -:  138:    
    #####:  139:    LOG_INFO("ImGuiManager initialized: " + std::to_string(width) + "x" + std::to_string(height));
        -:  140:    
        -:  141:    // Disable text input by default, enable only on focus
    #####:  142:    SDL_StopTextInput();
        -:  143:    
    #####:  144:    return true;
        -:  145:}
        -:  146:
    #####:  147:void ImGuiManager::shutdown() {
    #####:  148:    if (m_fontSmall) {
    #####:  149:        TTF_CloseFont(m_fontSmall);
    #####:  150:        m_fontSmall = nullptr;
        -:  151:    }
    #####:  152:    if (m_fontLarge) {
    #####:  153:        TTF_CloseFont(m_fontLarge);
    #####:  154:        m_fontLarge = nullptr;
        -:  155:    }
    #####:  156:    if (m_font) {
    #####:  157:        TTF_CloseFont(m_font);
    #####:  158:        m_font = nullptr;
        -:  159:    }
    #####:  160:    if (m_renderer) {
    #####:  161:        SDL_DestroyRenderer(m_renderer);
    #####:  162:        m_renderer = nullptr;
        -:  163:    }
    #####:  164:    if (m_window) {
    #####:  165:        SDL_DestroyWindow(m_window);
    #####:  166:        m_window = nullptr;
        -:  167:    }
    #####:  168:    TTF_Quit();
    #####:  169:}
        -:  170:
    #####:  171:void ImGuiManager::beginFrame() {
        -:  172:    // Clear with background color
        -:  173:    Uint8 r, g, b, a;
    #####:  174:    unpackColor(m_theme.background, r, g, b, a);
    #####:  175:    SDL_SetRenderDrawColor(m_renderer, r, g, b, a);
    #####:  176:    SDL_RenderClear(m_renderer);
        -:  177:    
        -:  178:    // Get current window size
    #####:  179:    SDL_GetWindowSize(m_window, &m_width, &m_height);
        -:  180:
        -:  181:    // Reset modal click state per frame - MOVED TO ENDFRAME
        -:  182:    // m_modalMouseClicked = false;
        -:  183:
    #####:  184:    m_state.scanDialogVisible = false;
    #####:  185:}
        -:  186:
    #####:  187:void ImGuiManager::endFrame() {
    #####:  188:    SDL_RenderPresent(m_renderer);
        -:  189:    
        -:  190:    // Reset click state after rendering so all UI elements can check it
    #####:  191:    m_mouseClicked = false;
    #####:  192:    m_modalMouseClicked = false;
    #####:  193:}
        -:  194:
    #####:  195:bool ImGuiManager::processEvent(const SDL_Event& event) {
    #####:  196:    switch (event.type) {
    #####:  197:        case SDL_MOUSEMOTION:
    #####:  198:            m_mouseX = event.motion.x;
    #####:  199:            m_mouseY = event.motion.y;
    #####:  200:            return true;
        -:  201:            
    #####:  202:        case SDL_MOUSEBUTTONDOWN:
    #####:  203:            if (event.button.button == SDL_BUTTON_LEFT)
        -:  204:            {
    #####:  205:                m_mouseDown = true;
        -:  206:                
        -:  207:                // Modal check for USB Dialog
    #####:  208:                if (m_state.showUsbDialog) 
        -:  209:                {
    #####:  210:                    m_modalMouseClicked = true;
        -:  211:                    // Do NOT set m_mouseClicked = true here.
        -:  212:                    // Only interaction with the specific dialog code in renderOverlays 
        -:  213:                    // should be allowed, which can use m_modalMouseClicked if needed, 
        -:  214:                    // or we just trust m_mouseClicked which will be false?
        -:  215:                    // Wait, renderOverlays uses m_mouseClicked.
        -:  216:                    // If we want to block others, we should set a specialized flag or 
        -:  217:                    // ensure others check "if (!showUsbDialog)" which is tedious.
        -:  218:                    // Better approach: Set m_mouseClicked = true, but ensure other panels check modality.
        -:  219:                    // OR: Use m_modalMouseClicked for modals and reset m_mouseClicked to false?
        -:  220:                    
        -:  221:                    // Let's rely on the strategy:
        -:  222:                    // If modal, set m_modalMouseClicked = true.
        -:  223:                    // Set m_mouseClicked = FALSE (so standard panels ignore it).
        -:  224:                    // Update renderOverlays to use m_modalMouseClicked for the USB dialog.
    #####:  225:                    m_mouseClicked = false; 
        -:  226:                }
    #####:  227:                else if (m_state.showChangePathDialog)
        -:  228:                {
    #####:  229:                    m_modalMouseClicked = true;
    #####:  230:                    m_mouseClicked = false;
        -:  231:                }
    #####:  232:                else if (m_state.scanDialogVisible)
        -:  233:                {
    #####:  234:                    m_modalMouseClicked = true;
    #####:  235:                    m_mouseClicked = false;
        -:  236:                }
        -:  237:                else
        -:  238:                {
    #####:  239:                    m_mouseClicked = true;
    #####:  240:                    m_modalMouseClicked = false;
        -:  241:                }
    #####:  242:                m_dragStartX = event.button.x;
    #####:  243:                m_dragStartY = event.button.y;
        -:  244:            }
    #####:  245:            return true;
        -:  246:            
    #####:  247:        case SDL_MOUSEBUTTONUP:
    #####:  248:            if (event.button.button == SDL_BUTTON_LEFT) {
    #####:  249:                m_mouseDown = false;
        -:  250:            }
    #####:  251:            return true;
        -:  252:            
    #####:  253:        case SDL_MOUSEWHEEL:
    #####:  254:            if (m_state.currentTab == NavTab::Library) {
    #####:  255:                m_state.scrollOffset -= event.wheel.y * 30;
    #####:  256:                if (m_state.scrollOffset < 0) m_state.scrollOffset = 0;
    #####:  257:            } else if (m_state.currentTab == NavTab::Queue) {
    #####:  258:                m_state.queueScrollOffset -= event.wheel.y * 30;
    #####:  259:                if (m_state.queueScrollOffset < 0) m_state.queueScrollOffset = 0;
    #####:  260:            } else if (m_state.currentTab == NavTab::History) {
    #####:  261:                m_state.historyScrollOffset -= event.wheel.y * 30;
    #####:  262:                if (m_state.historyScrollOffset < 0) m_state.historyScrollOffset = 0;
        -:  263:            }
    #####:  264:            return true;
        -:  265:        
    #####:  266:        case SDL_TEXTINPUT:
    #####:  267:            if (m_state.focusPathInput && (m_state.pathInputScreenVisible || m_state.showChangePathDialog)) {
    #####:  268:                m_state.libraryPathInput += event.text.text;
    #####:  269:            } else if (m_state.showCreatePlaylistDialog) {
    #####:  270:                m_state.newPlaylistName += event.text.text;
    #####:  271:            } else if (m_state.showRenamePlaylistDialog) {
    #####:  272:                m_state.renamePlaylistName += event.text.text;
    #####:  273:            } else if (m_state.currentTab == NavTab::Library) {
        -:  274:                // Add text to search query
    #####:  275:                m_state.searchQuery += event.text.text;
    #####:  276:                m_state.currentPage = 0;
    #####:  277:                m_state.scrollOffset = 0;
        -:  278:            }
    #####:  279:            return true;
        -:  280:            
    #####:  281:        case SDL_KEYDOWN:
    #####:  282:            if (!m_state.pathInputScreenVisible && !m_state.showChangePathDialog)
    #####:  283:                m_state.focusPathInput = false;
    #####:  284:            if (m_state.focusPathInput && (m_state.pathInputScreenVisible || m_state.showChangePathDialog)) {
    #####:  285:                if (event.key.keysym.sym == SDLK_BACKSPACE && !m_state.libraryPathInput.empty()) {
    #####:  286:                    m_state.libraryPathInput.pop_back();
    #####:  287:                } else if (event.key.keysym.sym == SDLK_RETURN || event.key.keysym.sym == SDLK_KP_ENTER) {
    #####:  288:                    if (m_state.showChangePathDialog && m_onChangeLibraryPath)
    #####:  289:                        m_onChangeLibraryPath(m_state.libraryPathInput);
    #####:  290:                    else if (m_onRequestScan)
    #####:  291:                        m_onRequestScan(m_state.libraryPathInput);
    #####:  292:                } else if (event.key.keysym.sym == SDLK_ESCAPE) {
    #####:  293:                    m_state.focusPathInput = false;
    #####:  294:                    if (m_state.showChangePathDialog) m_state.showChangePathDialog = false;
    #####:  295:                    SDL_StopTextInput();
        -:  296:                }
    #####:  297:            } else if (m_state.showCreatePlaylistDialog) {
        -:  298:                // Playlist Dialog Input
    #####:  299:                if (event.key.keysym.sym == SDLK_BACKSPACE && !m_state.newPlaylistName.empty()) {
    #####:  300:                    m_state.newPlaylistName.pop_back();
    #####:  301:                } else if (event.key.keysym.sym == SDLK_ESCAPE) {
    #####:  302:                    m_state.showCreatePlaylistDialog = false;
    #####:  303:                    m_state.newPlaylistName.clear();
    #####:  304:                    SDL_StopTextInput();
    #####:  305:                } else if (event.key.keysym.sym == SDLK_RETURN || event.key.keysym.sym == SDLK_KP_ENTER) {
    #####:  306:                    if (!m_state.newPlaylistName.empty() && m_playlistController) {
    #####:  307:                        m_playlistController->createPlaylist(m_state.newPlaylistName);
    #####:  308:                        m_state.showCreatePlaylistDialog = false;
    #####:  309:                        m_state.newPlaylistName.clear();
    #####:  310:                        SDL_StopTextInput();
        -:  311:                    }
        -:  312:                }
    #####:  313:            } else if (m_state.showRenamePlaylistDialog) {
    #####:  314:                if (event.key.keysym.sym == SDLK_BACKSPACE && !m_state.renamePlaylistName.empty()) {
    #####:  315:                    m_state.renamePlaylistName.pop_back();
    #####:  316:                } else if (event.key.keysym.sym == SDLK_ESCAPE) {
    #####:  317:                    m_state.showRenamePlaylistDialog = false;
    #####:  318:                    SDL_StopTextInput();
    #####:  319:                } else if (event.key.keysym.sym == SDLK_RETURN || event.key.keysym.sym == SDLK_KP_ENTER) {
    #####:  320:                    if (!m_state.renamePlaylistName.empty() && m_playlistController) {
    #####:  321:                        m_playlistController->renamePlaylist(m_state.renamePlaylistId, m_state.renamePlaylistName);
        -:  322:                    }
    #####:  323:                    m_state.showRenamePlaylistDialog = false;
    #####:  324:                    SDL_StopTextInput();
        -:  325:                }
        -:  326:            } else {
        -:  327:                // Global Shortcuts / Search
    #####:  328:                if (event.key.keysym.sym == SDLK_BACKSPACE && !m_state.searchQuery.empty()) {
    #####:  329:                    m_state.searchQuery.pop_back();
    #####:  330:                    m_state.currentPage = 0;
    #####:  331:                    m_state.scrollOffset = 0;
    #####:  332:                } else if (event.key.keysym.sym == SDLK_ESCAPE) {
    #####:  333:                    m_state.searchQuery.clear();
    #####:  334:                    m_state.searchFocused = false;
    #####:  335:                    m_state.currentPage = 0;
    #####:  336:                    m_state.scrollOffset = 0;
        -:  337:                }
        -:  338:            }
    #####:  339:            return true;
        -:  340:            
    #####:  341:        default:
    #####:  342:            break;
        -:  343:    }
    #####:  344:    return false;
        -:  345:}
        -:  346:
    #####:  347:void ImGuiManager::handleResize(int width, int height) {
    #####:  348:    m_width = width;
    #####:  349:    m_height = height;
    #####:  350:}
        -:  351:
    #####:  352:void ImGuiManager::renderMainLayout() {
    #####:  353:    renderMenuBar();
    #####:  354:    renderSidebar();
    #####:  355:    renderPlayerBar();
        -:  356:    
        -:  357:    // Main content area
    #####:  358:    int contentX = SIDEBAR_WIDTH;
    #####:  359:    int contentY = MENU_BAR_HEIGHT;
    #####:  360:    int contentW = m_width - SIDEBAR_WIDTH;
    #####:  361:    int contentH = m_height - MENU_BAR_HEIGHT - PLAYER_BAR_HEIGHT;
        -:  362:    
        -:  363:    // Draw content background
    #####:  364:    drawRect(contentX, contentY, contentW, contentH, m_theme.background);
        -:  365:    
        -:  366:    // Nếu đang phát video, render video panel thay vì content thông thường
    #####:  367:    if (m_state.isPlayingVideo && m_state.videoTexture)
        -:  368:    {
        -:  369:        // Tính toán kích thước video giữ tỷ lệ khung hình
    #####:  370:        int videoW = m_state.videoWidth;
    #####:  371:        int videoH = m_state.videoHeight;
        -:  372:        
    #####:  373:        if (videoW > 0 && videoH > 0)
        -:  374:        {
    #####:  375:            float aspectRatio = static_cast<float>(videoW) / static_cast<float>(videoH);
    #####:  376:            float contentAspect = static_cast<float>(contentW) / static_cast<float>(contentH);
        -:  377:            
        -:  378:            int renderW, renderH;
    #####:  379:            if (aspectRatio > contentAspect)
        -:  380:            {
        -:  381:                // Video rộng hơn - fit theo chiều ngang
    #####:  382:                renderW = contentW;
    #####:  383:                renderH = static_cast<int>(contentW / aspectRatio);
        -:  384:            }
        -:  385:            else
        -:  386:            {
        -:  387:                // Video cao hơn - fit theo chiều dọc
    #####:  388:                renderH = contentH;
    #####:  389:                renderW = static_cast<int>(contentH * aspectRatio);
        -:  390:            }
        -:  391:            
        -:  392:            // Center video trong content area
    #####:  393:            int renderX = contentX + (contentW - renderW) / 2;
    #####:  394:            int renderY = contentY + (contentH - renderH) / 2;
        -:  395:            
        -:  396:            // Render video texture
    #####:  397:            SDL_Rect destRect = {renderX, renderY, renderW, renderH};
    #####:  398:            SDL_RenderCopy(m_renderer, m_state.videoTexture, nullptr, &destRect);
        -:  399:        }
        -:  400:        
        -:  401:        // Vẫn render overlays (context menu, dialogs, etc.)
    #####:  402:        renderOverlays();
    #####:  403:        return;
        -:  404:    }
        -:  405:    
        -:  406:    // Render current view
    #####:  407:    switch (m_state.currentTab) {
    #####:  408:        case NavTab::Library:
    #####:  409:            renderLibraryPanel();
    #####:  410:            break;
    #####:  411:        case NavTab::Playlists:
    #####:  412:            renderPlaylistPanel();
    #####:  413:            break;
    #####:  414:        case NavTab::Queue:
    #####:  415:            renderQueuePanel();
    #####:  416:            break;
    #####:  417:        case NavTab::History:
    #####:  418:            renderHistoryPanel();
    #####:  419:            break;
    #####:  420:        case NavTab::Settings: {
    #####:  421:            drawText("Settings", contentX + 20, contentY + 20, m_theme.textPrimary, 24);
    #####:  422:            int sy = contentY + 60;
    #####:  423:            drawText("Thư mục thư viện:", contentX + 20, sy, m_theme.textSecondary, 14);
    #####:  424:            std::string currentPath = m_getCurrentLibraryPath ? m_getCurrentLibraryPath() : "";
    #####:  425:            if (currentPath.length() > 50) currentPath = "..." + currentPath.substr(currentPath.length() - 47);
    #####:  426:            drawText(currentPath, contentX + 20, sy + 22, m_theme.textPrimary, 12);
    #####:  427:            int btnX = contentX + 20;
    #####:  428:            int btnY = sy + 55;
    #####:  429:            int btnW = 140;
    #####:  430:            int btnH = 32;
    #####:  431:            bool changeHover = isMouseOver(btnX, btnY, btnW, btnH);
    #####:  432:            drawRect(btnX, btnY, btnW, btnH, changeHover ? m_theme.primaryHover : m_theme.primary);
    #####:  433:            drawText("Đổi đường dẫn", btnX + 18, btnY + 8, m_theme.textPrimary, 14);
    #####:  434:            if (changeHover && m_mouseClicked) {
    #####:  435:                m_state.libraryPathInput = m_getCurrentLibraryPath ? m_getCurrentLibraryPath() : "";
    #####:  436:                m_state.showChangePathDialog = true;
    #####:  437:                m_state.focusPathInput = true;
    #####:  438:                SDL_StartTextInput();
    #####:  439:                m_mouseClicked = false;
        -:  440:            }
    #####:  441:            break;
    #####:  442:        }
        -:  443:    }
        -:  444:    
    #####:  445:    renderOverlays();
        -:  446:}
        -:  447:
    #####:  448:void ImGuiManager::renderMenuBar() {
        -:  449:    // Menu bar background
    #####:  450:    drawRect(0, 0, m_width, MENU_BAR_HEIGHT, m_theme.surface);
        -:  451:    
        -:  452:    // App title
    #####:  453:    drawText("Media Player", 10, 6, m_theme.textPrimary, 14);
        -:  454:    
        -:  455:    // Search box - only show when Library tab is active
    #####:  456:    if (m_state.currentTab == NavTab::Library) {
    #####:  457:        int searchX = m_width - 250;
    #####:  458:        int searchW = 200;
    #####:  459:        int searchY = 4;
    #####:  460:        int searchH = MENU_BAR_HEIGHT - 8;
    #####:  461:        bool searchHover = isMouseOver(searchX, searchY, searchW, searchH);
    #####:  462:        drawRect(searchX, searchY, searchW, searchH, (m_state.searchFocused || searchHover) ? m_theme.surfaceActive : m_theme.surfaceHover, true);
    #####:  463:        if (searchHover && m_mouseClicked) {
    #####:  464:            m_state.searchFocused = true;
    #####:  465:            SDL_Rect searchRect = {searchX, searchY, searchW, searchH};
    #####:  466:            SDL_SetTextInputRect(&searchRect);
    #####:  467:            SDL_StartTextInput();
        -:  468:        }
    #####:  469:        if (m_state.searchQuery.empty()) {
    #####:  470:            drawText("Search...", searchX + 8, 7, m_theme.textDim, 12);
        -:  471:        } else {
    #####:  472:            std::string displayQuery = m_state.searchQuery;
    #####:  473:            if (displayQuery.length() > 25) displayQuery = displayQuery.substr(0, 22) + "...";
    #####:  474:            drawText(displayQuery, searchX + 8, 7, m_theme.textPrimary, 12);
    #####:  475:        }
    #####:  476:        if (m_state.searchFocused && m_mouseClicked && !searchHover) {
    #####:  477:            m_state.searchFocused = false;
        -:  478:        }
        -:  479:    } else {
    #####:  480:        m_state.searchFocused = false;
        -:  481:    }
        -:  482:    
        -:  483:    // Bottom border
    #####:  484:    drawRect(0, MENU_BAR_HEIGHT - 1, m_width, 1, m_theme.border);
    #####:  485:}
        -:  486:
    #####:  487:void ImGuiManager::renderSidebar() {
    #####:  488:    int y = MENU_BAR_HEIGHT;
    #####:  489:    int h = m_height - MENU_BAR_HEIGHT - PLAYER_BAR_HEIGHT;
        -:  490:    
        -:  491:    // Sidebar background
    #####:  492:    drawRect(0, y, SIDEBAR_WIDTH, h, m_theme.surface);
        -:  493:    
        -:  494:    // Navigation items
        -:  495:    struct NavItem {
        -:  496:        const char* icon;
        -:  497:        const char* label;
        -:  498:        NavTab tab;
        -:  499:    };
        -:  500:    
    #####:  501:    NavItem items[] = {
        -:  502:        {">", "Library", NavTab::Library},
        -:  503:        {"#", "Playlists", NavTab::Playlists},
        -:  504:        {"=", "Queue", NavTab::Queue},
        -:  505:        {"@", "History", NavTab::History}
        -:  506:    };
        -:  507:    
    #####:  508:    int itemY = y + 20;
    #####:  509:    int itemH = 40;
        -:  510:    
    #####:  511:    for (const auto& item : items) {
    #####:  512:        bool selected = (m_state.currentTab == item.tab);
    #####:  513:        bool hover = isMouseOver(0, itemY, SIDEBAR_WIDTH, itemH);
        -:  514:        
        -:  515:        // Background
    #####:  516:        if (selected) {
    #####:  517:            drawRect(0, itemY, SIDEBAR_WIDTH, itemH, m_theme.primary);
    #####:  518:        } else if (hover) {
    #####:  519:            drawRect(0, itemY, SIDEBAR_WIDTH, itemH, m_theme.surfaceHover);
        -:  520:        }
        -:  521:        
        -:  522:        // Accent bar for selected
    #####:  523:        if (selected) {
    #####:  524:            drawRect(0, itemY, 4, itemH, m_theme.primaryActive);
        -:  525:        }
        -:  526:        
        -:  527:        // Icon and label
    #####:  528:        uint32_t textColor = selected ? m_theme.textPrimary : 
    #####:  529:                            (hover ? m_theme.textPrimary : m_theme.textSecondary);
        -:  530:        
    #####:  531:        drawText(item.icon, 15, itemY + 10, textColor, 16);
    #####:  532:        drawText(item.label, 45, itemY + 12, textColor, 14);
        -:  533:        
        -:  534:        // Handle click
    #####:  535:        if (hover && m_mouseClicked) {
    #####:  536:            m_state.currentTab = item.tab;
    #####:  537:            m_state.searchFocused = false;
        -:  538:        }
        -:  539:        
    #####:  540:        itemY += itemH;
        -:  541:    }
        -:  542:    
        -:  543:    // Separator line
    #####:  544:    drawRect(10, itemY + 10, SIDEBAR_WIDTH - 20, 1, m_theme.border);
    #####:  545:    itemY += 25;
        -:  546:    
        -:  547:    // "Change Source" button - below History
    #####:  548:    bool changeSourceHover = isMouseOver(10, itemY, SIDEBAR_WIDTH - 20, 36);
    #####:  549:    uint32_t changeBtnColor = changeSourceHover ? m_theme.surfaceHover : m_theme.surface;
    #####:  550:    drawRect(10, itemY, SIDEBAR_WIDTH - 20, 36, changeBtnColor);
    #####:  551:    drawRect(10, itemY, SIDEBAR_WIDTH - 20, 36, m_theme.border, false);
        -:  552:    
    #####:  553:    uint32_t changeTextColor = changeSourceHover ? m_theme.textPrimary : m_theme.textSecondary;
    #####:  554:    drawText("~", 20, itemY + 8, changeTextColor, 16);
    #####:  555:    drawText("Change Source", 45, itemY + 10, changeTextColor, 12);
        -:  556:    
        -:  557:    // Stop (Quit) Button - Bottom Left
    #####:  558:    int stopBtnH = 36;
    #####:  559:    int stopBtnY = m_height - PLAYER_BAR_HEIGHT - stopBtnH - 10;
    #####:  560:    bool stopHover = isMouseOver(10, stopBtnY, SIDEBAR_WIDTH - 20, stopBtnH);
    #####:  561:    drawRect(10, stopBtnY, SIDEBAR_WIDTH - 20, stopBtnH, stopHover ? m_theme.error : m_theme.surfaceActive);
    #####:  562:    drawText("Quit App", 45, stopBtnY + 10, m_theme.textPrimary, 12);
        -:  563:    
    #####:  564:    if (stopHover && m_mouseClicked && m_onQuit) {
    #####:  565:        m_onQuit();
    #####:  566:        m_mouseClicked = false;
        -:  567:    }
        -:  568:    
    #####:  569:    if (changeSourceHover && m_mouseClicked) {
        -:  570:        // Open the change path dialog
    #####:  571:        m_state.libraryPathInput = m_getCurrentLibraryPath ? m_getCurrentLibraryPath() : "";
    #####:  572:        m_state.showChangePathDialog = true;
    #####:  573:        m_state.focusPathInput = true;
    #####:  574:        SDL_StartTextInput();
    #####:  575:        m_mouseClicked = false;
        -:  576:    }
        -:  577:    
        -:  578:    // Right border
    #####:  579:    drawRect(SIDEBAR_WIDTH - 1, y, 1, h, m_theme.border);
    #####:  580:}
        -:  581:
    #####:  582:void ImGuiManager::renderLibraryPanel() {
    #####:  583:    if (!m_mediaList) return;
        -:  584:    
    #####:  585:    int x = SIDEBAR_WIDTH + 10;
    #####:  586:    int y = MENU_BAR_HEIGHT + 10;
    #####:  587:    int w = m_width - SIDEBAR_WIDTH - 20;
    #####:  588:    int h = m_height - MENU_BAR_HEIGHT - PLAYER_BAR_HEIGHT - 20;
        -:  589:    
        -:  590:    // 1. Calculate filtered list first
    #####:  591:    std::vector<size_t> filteredIndices;
    #####:  592:    filteredIndices.reserve(m_mediaList->size());
        -:  593:    
    #####:  594:    for (size_t i = 0; i < m_mediaList->size(); i++) {
    #####:  595:        const auto& media = (*m_mediaList)[i];
        -:  596:        
    #####:  597:        if (m_state.searchQuery.empty()) {
    #####:  598:            filteredIndices.push_back(i);
        -:  599:        } else {
        -:  600:            // Case-insensitive search
    #####:  601:            std::string query = m_state.searchQuery;
    #####:  602:            std::transform(query.begin(), query.end(), query.begin(), ::tolower);
        -:  603:            
    #####:  604:            std::string title = media.getTitle().empty() ? media.getFileName() : media.getTitle();
    #####:  605:            std::transform(title.begin(), title.end(), title.begin(), ::tolower);
        -:  606:            
    #####:  607:            std::string artist = media.getArtist();
    #####:  608:            std::transform(artist.begin(), artist.end(), artist.begin(), ::tolower);
        -:  609:            
    #####:  610:            std::string album = media.getAlbum();
    #####:  611:            std::transform(album.begin(), album.end(), album.begin(), ::tolower);
        -:  612:            
    #####:  613:            bool matches = false;
    #####:  614:            switch (m_state.searchFilter) {
    #####:  615:                case SearchFilter::All:
    #####:  616:                    matches = (title.find(query) != std::string::npos || 
    #####:  617:                               artist.find(query) != std::string::npos ||
    #####:  618:                               album.find(query) != std::string::npos);
    #####:  619:                    break;
    #####:  620:                case SearchFilter::Title:
    #####:  621:                    matches = (title.find(query) != std::string::npos);
    #####:  622:                    break;
    #####:  623:                case SearchFilter::Artist:
    #####:  624:                    matches = (artist.find(query) != std::string::npos);
    #####:  625:                    break;
    #####:  626:                case SearchFilter::Album:
    #####:  627:                    matches = (album.find(query) != std::string::npos);
    #####:  628:                    break;
        -:  629:            }
    #####:  630:            if (matches) {
    #####:  631:                filteredIndices.push_back(i);
        -:  632:            }
    #####:  633:        }
        -:  634:    }
        -:  635:    
    #####:  636:    int filteredCount = static_cast<int>(filteredIndices.size());
    #####:  637:    int totalPages = (filteredCount + UIState::ITEMS_PER_PAGE - 1) / UIState::ITEMS_PER_PAGE;
    #####:  638:    if (totalPages == 0) totalPages = 1;
        -:  639:
        -:  640:    // Sort Logic including Album (Field 3? Let's use 2 and move Duration to 3)
        -:  641:    // 0=Title, 1=Artist, 2=Album, 3=Duration
    #####:  642:    if (m_state.sortField != -1 && !filteredIndices.empty()) { 
    #####:  643:         std::stable_sort(filteredIndices.begin(), filteredIndices.end(), 
    #####:  644:            [&](size_t a, size_t b) {
    #####:  645:                const auto& mA = (*m_mediaList)[a];
    #####:  646:                const auto& mB = (*m_mediaList)[b];
    #####:  647:                int cmp = 0;
    #####:  648:                if (m_state.sortField == 0) { // Title
    #####:  649:                    std::string tA = mA.getTitle().empty() ? mA.getFileName() : mA.getTitle();
    #####:  650:                    std::string tB = mB.getTitle().empty() ? mB.getFileName() : mB.getTitle();
    #####:  651:                    cmp = tA.compare(tB);
    #####:  652:                } else if (m_state.sortField == 1) { // Artist
    #####:  653:                    cmp = mA.getArtist().compare(mB.getArtist());
    #####:  654:                } else if (m_state.sortField == 2) { // Album
    #####:  655:                    cmp = mA.getAlbum().compare(mB.getAlbum());
    #####:  656:                } else if (m_state.sortField == 3) { // Duration
    #####:  657:                    int dA = mA.getDuration();
    #####:  658:                    int dB = mB.getDuration();
    #####:  659:                    cmp = (dA < dB) ? -1 : ((dA > dB) ? 1 : 0);
        -:  660:                }
    #####:  661:                return m_state.sortAscending ? (cmp < 0) : (cmp > 0);
        -:  662:            });
        -:  663:    }
        -:  664:
        -:  665:    // 2. Header
    #####:  666:    drawText("Library", x, y, m_theme.textPrimary, 20);
        -:  667:    
        -:  668:    // Search filter buttons (only show when search query is not empty)
    #####:  669:    if (!m_state.searchQuery.empty()) {
    #####:  670:        int filterX = x + 90;
    #####:  671:        int filterY = y + 2;
    #####:  672:        int filterBtnW = 55;
    #####:  673:        int filterBtnH = 22;
    #####:  674:        int filterGap = 5;
        -:  675:        
        -:  676:        struct FilterBtn {
        -:  677:            const char* label;
        -:  678:            SearchFilter filter;
        -:  679:        };
    #####:  680:        FilterBtn filters[] = {
        -:  681:            {"All", SearchFilter::All},
        -:  682:            {"Title", SearchFilter::Title},
        -:  683:            {"Artist", SearchFilter::Artist},
        -:  684:            {"Album", SearchFilter::Album}
        -:  685:        };
        -:  686:        
    #####:  687:        for (const auto& fb : filters) {
    #####:  688:            bool selected = (m_state.searchFilter == fb.filter);
    #####:  689:            bool hover = isMouseOver(filterX, filterY, filterBtnW, filterBtnH);
        -:  690:            
    #####:  691:            uint32_t btnColor = selected ? m_theme.primary : 
    #####:  692:                               (hover ? m_theme.surfaceHover : m_theme.surface);
    #####:  693:            drawRect(filterX, filterY, filterBtnW, filterBtnH, btnColor);
    #####:  694:            drawRect(filterX, filterY, filterBtnW, filterBtnH, m_theme.border, false);
        -:  695:            
    #####:  696:            uint32_t textColor = selected ? m_theme.textPrimary : m_theme.textSecondary;
    #####:  697:            drawText(fb.label, filterX + 8, filterY + 4, textColor, 11);
        -:  698:            
    #####:  699:            if (hover && m_mouseClicked) {
    #####:  700:                m_state.searchFilter = fb.filter;
    #####:  701:                m_state.currentPage = 0;
    #####:  702:                m_mouseClicked = false;
        -:  703:            }
        -:  704:            
    #####:  705:            filterX += filterBtnW + filterGap;
        -:  706:        }
        -:  707:        
        -:  708:        // Clear Search Button (X) - After filters
    #####:  709:        int clearBtnSize = 22;
    #####:  710:        int clearX = filterX + 5;
        -:  711:        
    #####:  712:        bool clearHover = isMouseOver(clearX, filterY, clearBtnSize, clearBtnSize);
    #####:  713:        if (clearHover) {
    #####:  714:             drawRect(clearX, filterY, clearBtnSize, clearBtnSize, m_theme.surfaceActive);
        -:  715:        }
    #####:  716:        drawRect(clearX, filterY, clearBtnSize, clearBtnSize, m_theme.border, false);
    #####:  717:        drawText("x", clearX + 7, filterY + 2, m_theme.textDim, 14);
        -:  718:        
    #####:  719:        if (clearHover && m_mouseClicked) {
    #####:  720:            m_state.searchQuery.clear();
    #####:  721:            m_state.currentPage = 0;
    #####:  722:            m_state.scrollOffset = 0;
    #####:  723:            SDL_StopTextInput();
    #####:  724:            m_mouseClicked = false;
        -:  725:        }
        -:  726:    }
        -:  727:    
    #####:  728:    std::string pageInfo = "Page " + std::to_string(m_state.currentPage + 1) + "/" + std::to_string(totalPages);
    #####:  729:    std::string countText = std::to_string(filteredCount) + " tracks";
        -:  730:    
    #####:  731:    drawText(countText, x + w - 180, y + 4, m_theme.textDim, 12);
    #####:  732:    drawText(pageInfo, x + w - 80, y + 4, m_theme.textSecondary, 12);
        -:  733:    
    #####:  734:    y += 40;
        -:  735:    
        -:  736:    // 3. Column headers
    #####:  737:    int colTitle = x;
    #####:  738:    int colArtist = x + w * 0.35;
    #####:  739:    int colAlbum = x + w * 0.6;
    #####:  740:    int colDuration = x + w - 70;
        -:  741:    
    #####:  742:    drawRect(x, y, w, 30, m_theme.surface);
        -:  743:    
        -:  744:    // Title header
    #####:  745:    bool titleHover = isMouseOver(colTitle, y, static_cast<int>(w * 0.35), 30);
    #####:  746:    std::string titleHeader = "Title";
    #####:  747:    if (m_state.sortField == 0) titleHeader += m_state.sortAscending ? " ^" : " v";
    #####:  748:    drawText(titleHeader, colTitle + 50, y + 7, titleHover ? m_theme.textPrimary : m_theme.textSecondary, 12);
    #####:  749:    if (titleHover && m_mouseClicked) {
    #####:  750:        if (m_state.sortField == 0) m_state.sortAscending = !m_state.sortAscending;
    #####:  751:        else { m_state.sortField = 0; m_state.sortAscending = true; }
        -:  752:    }
        -:  753:    
        -:  754:    // Artist header
    #####:  755:    bool artistHover = isMouseOver(colArtist, y, static_cast<int>(w * 0.25), 30);
    #####:  756:    std::string artistHeader = "Artist";
    #####:  757:    if (m_state.sortField == 1) artistHeader += m_state.sortAscending ? " ^" : " v";
    #####:  758:    drawText(artistHeader, colArtist, y + 7, artistHover ? m_theme.textPrimary : m_theme.textSecondary, 12);
    #####:  759:    if (artistHover && m_mouseClicked) {
    #####:  760:        if (m_state.sortField == 1) m_state.sortAscending = !m_state.sortAscending;
    #####:  761:        else { m_state.sortField = 1; m_state.sortAscending = true; }
        -:  762:    }
        -:  763:
        -:  764:    // Album header
    #####:  765:    bool albumHover = isMouseOver(colAlbum, y, static_cast<int>(w * 0.25), 30);
    #####:  766:    std::string albumHeader = "Album";
    #####:  767:    if (m_state.sortField == 2) albumHeader += m_state.sortAscending ? " ^" : " v";
    #####:  768:    drawText(albumHeader, colAlbum, y + 7, albumHover ? m_theme.textPrimary : m_theme.textSecondary, 12);
    #####:  769:    if (albumHover && m_mouseClicked) {
    #####:  770:        if (m_state.sortField == 2) m_state.sortAscending = !m_state.sortAscending;
    #####:  771:        else { m_state.sortField = 2; m_state.sortAscending = true; }
        -:  772:    }
        -:  773:    
        -:  774:    // Duration header
    #####:  775:    bool durHover = isMouseOver(colDuration, y, 70, 30);
    #####:  776:    std::string durHeader = "Time";
    #####:  777:    if (m_state.sortField == 3) durHeader += m_state.sortAscending ? " ^" : " v";
    #####:  778:    drawText(durHeader, colDuration, y + 7, durHover ? m_theme.textPrimary : m_theme.textSecondary, 12);
    #####:  779:    if (durHover && m_mouseClicked) {
    #####:  780:        if (m_state.sortField == 3) m_state.sortAscending = !m_state.sortAscending;
    #####:  781:        else { m_state.sortField = 3; m_state.sortAscending = true; }
        -:  782:    }
        -:  783:    
    #####:  784:    y += 30;
        -:  785:    
        -:  786:    // 4. Media list
    #####:  787:    int listH = h - 110; // Leave room for pagination buttons (40px buttons + padding)
        -:  788:    
        -:  789:    // Set Clip Rect (if we had SDL_RenderSetClipRect)
    #####:  790:    SDL_Rect clipRect = { x, y, w, listH };
    #####:  791:    SDL_RenderSetClipRect(m_renderer, &clipRect);
        -:  792:
        -:  793:    // int visibleItems = listH / ITEM_HEIGHT; // Unused since using pagination loop
        -:  794:    
        -:  795:    // Pagination logic
    #####:  796:    if (m_state.currentPage >= totalPages) m_state.currentPage = totalPages - 1;
    #####:  797:    if (m_state.currentPage < 0) m_state.currentPage = 0;
        -:  798:    
    #####:  799:    int startIndex = m_state.currentPage * UIState::ITEMS_PER_PAGE;
    #####:  800:    int endIndex = std::min(startIndex + UIState::ITEMS_PER_PAGE, filteredCount);
        -:  801:    
        -:  802:    // Use visibleItems? No, we use Pagination now (25 items/page).
        -:  803:    // Render the current page items
        -:  804:    
    #####:  805:    for (int i = startIndex; i < endIndex; i++) {
    #####:  806:        size_t index = filteredIndices[i];
    #####:  807:        const auto& media = (*m_mediaList)[index];
        -:  808:        
        -:  809:        // Render item relative to y + Scroll Offset
    #####:  810:        int rowIdx = i - startIndex; // 0 to 24
    #####:  811:        int itemY = y + (rowIdx * ITEM_HEIGHT) - m_state.scrollOffset;
        -:  812:        
        -:  813:        // Culling (skip items outside view)
    #####:  814:        if (itemY + ITEM_HEIGHT < y || itemY > y + listH) continue;
        -:  815:        
    #####:  816:        bool selected = (index == static_cast<size_t>(m_state.selectedMediaIndex));
    #####:  817:        bool hover = isMouseOver(x, itemY, w, ITEM_HEIGHT); // Note: isMouseOver needs to account for Clip Rect if implemented in engine, but here simple coord check
        -:  818:        // Check if mouse inside List Area
    #####:  819:        bool mouseInList = isMouseOver(x, y, w, listH);
    #####:  820:        hover = hover && mouseInList;
        -:  821:
    #####:  822:        uint32_t rowBg = selected ? m_theme.surfaceActive : 
    #####:  823:                        (hover ? m_theme.surfaceHover : 
    #####:  824:                        (i % 2 == 0 ? m_theme.background : m_theme.surface));
    #####:  825:        drawRect(x, itemY, w, ITEM_HEIGHT, rowBg);
        -:  826:        
        -:  827:        // Right click context menu
        -:  828:        int mx, my;
    #####:  829:        uint32_t buttons = SDL_GetMouseState(&mx, &my);
    #####:  830:        if (hover && mouseInList && (buttons & SDL_BUTTON(SDL_BUTTON_RIGHT))) {
    #####:  831:             m_state.showContextMenu = true;
    #####:  832:             m_state.contextMenuX = mx;
    #####:  833:             m_state.contextMenuY = my;
    #####:  834:             m_state.selectedContextItemIndex = static_cast<int>(index);
    #####:  835:             m_state.contextMediaItem = (*m_mediaList)[index];
    #####:  836:             m_state.contextMenuSource = ui::ContextMenuSource::Library;
        -:  837:        }
        -:  838:        
    #####:  839:        if (index == static_cast<size_t>(m_state.selectedMediaIndex) && m_state.isPlaying) {
    #####:  840:            drawRect(x, itemY, 4, ITEM_HEIGHT, m_theme.success);
    #####:  841:            drawText(">", x + 15, itemY + 15, m_theme.success, 14);
        -:  842:        } else {
    #####:  843:            const char* icon = media.isAudio() ? "~" : (media.isVideo() ? "*" : "?");
    #####:  844:            uint32_t iconColor = media.isUnsupported() ? m_theme.textDim : m_theme.textSecondary;
    #####:  845:            drawText(icon, x + 15, itemY + 15, iconColor, 14);
        -:  846:        }
        -:  847:        
    #####:  848:        uint32_t textCol = media.isUnsupported() ? m_theme.textDim : m_theme.textPrimary;
    #####:  849:        uint32_t subCol = media.isUnsupported() ? m_theme.textDim : m_theme.textSecondary;
        -:  850:
    #####:  851:        std::string title = media.getTitle().empty() ? media.getFileName() : media.getTitle();
    #####:  852:        if (title.length() > 35) title = title.substr(0, 32) + "...";
    #####:  853:        drawText(title, colTitle + 50, itemY + 15, textCol, 14);
        -:  854:        
    #####:  855:        std::string artist = media.getArtist().empty() ? "Unknown Artist" : media.getArtist();
    #####:  856:        if (artist.length() > 25) artist = artist.substr(0, 22) + "...";
    #####:  857:        drawText(artist, colArtist, itemY + 15, subCol, 14);
        -:  858:        
    #####:  859:        std::string album = media.getAlbum();
    #####:  860:        if (album.length() > 25) album = album.substr(0, 22) + "...";
    #####:  861:        drawText(album, colAlbum, itemY + 15, subCol, 14);
        -:  862:
    #####:  863:        int duration = media.getDuration();
    #####:  864:        std::string durationStr = "--:--";
    #####:  865:        if (duration > 0) {
    #####:  866:            int mins = duration / 60;
    #####:  867:            int secs = duration % 60;
    #####:  868:            std::ostringstream oss;
    #####:  869:            oss << mins << ":" << std::setfill('0') << std::setw(2) << secs;
    #####:  870:            durationStr = oss.str();
    #####:  871:        }
    #####:  872:        drawText(durationStr, colDuration, itemY + 15, m_theme.textDim, 12);
        -:  873:        
        -:  874:        // Prevent click if unsupported
    #####:  875:        if (hover && m_mouseClicked && !m_state.showContextMenu && !m_state.showAddToPlaylistDialog && !m_state.showPropertiesDialog && !m_state.showCreatePlaylistDialog && !m_state.showRenamePlaylistDialog) {
    #####:  876:            if (!media.isUnsupported()) {
    #####:  877:                m_state.selectedMediaIndex = static_cast<int>(index);
    #####:  878:                if (m_onPlay) {
    #####:  879:                    m_onPlay(static_cast<int>(index));
    #####:  880:                    m_mouseClicked = false; // Consume click to prevent play/pause toggle
        -:  881:                }
        -:  882:            } else {
        -:  883:                // Consume click but do nothing for unsupported files
    #####:  884:                m_mouseClicked = false;
        -:  885:            }
        -:  886:        }
    #####:  887:    }
        -:  888:    
        -:  889:    // Reset Clip Rect
    #####:  890:    SDL_RenderSetClipRect(m_renderer, nullptr);
        -:  891:
        -:  892:    // 5. Pagination Buttons (Fixed at bottom of list area)
    #####:  893:    int pageBtnsY = y + listH + 10;
    #####:  894:    int prevBtnX = x + w/2 - 100;
    #####:  895:    int nextBtnX = x + w/2 + 20;
        -:  896:
    #####:  897:    if (m_state.currentPage > 0) {
    #####:  898:        bool prevHover = isMouseOver(prevBtnX, pageBtnsY, 80, 28);
    #####:  899:        drawRect(prevBtnX, pageBtnsY, 80, 28, prevHover ? m_theme.primaryHover : m_theme.primary);
    #####:  900:        drawText("< Prev", prevBtnX + 15, pageBtnsY + 6, m_theme.textPrimary, 12);
    #####:  901:        if (prevHover && m_mouseClicked) m_state.currentPage--;
        -:  902:    }
        -:  903:
    #####:  904:    if (m_state.currentPage < totalPages - 1) {
    #####:  905:        bool nextHover = isMouseOver(nextBtnX, pageBtnsY, 80, 28);
    #####:  906:        drawRect(nextBtnX, pageBtnsY, 80, 28, nextHover ? m_theme.primaryHover : m_theme.primary);
    #####:  907:        drawText("Next >", nextBtnX + 15, pageBtnsY + 6, m_theme.textPrimary, 12);
    #####:  908:        if (nextHover && m_mouseClicked) m_state.currentPage++;
        -:  909:    }
    #####:  910:}
        -:  911:
    #####:  912:void ImGuiManager::renderPlayerBar() {
    #####:  913:    int y = m_height - PLAYER_BAR_HEIGHT;
        -:  914:    
        -:  915:    // Background
    #####:  916:    drawRect(0, y, m_width, PLAYER_BAR_HEIGHT, m_theme.surface);
        -:  917:    
        -:  918:    // Top border
    #####:  919:    drawRect(0, y, m_width, 1, m_theme.border);
        -:  920:    
        -:  921:    // Album art placeholder
    #####:  922:    int artSize = 70;
    #####:  923:    int artX = 10;
    #####:  924:    int artY = y + 10;
    #####:  925:    drawRect(artX, artY, artSize, artSize, m_theme.surfaceHover);
    #####:  926:    drawText("~", artX + 25, artY + 22, m_theme.textDim, 24);
        -:  927:    
        -:  928:    // Track info (truncate so text does not overlap playback controls)
    #####:  929:    int infoX = artX + artSize + 15;
    #####:  930:    int maxTitleLen = 36;
    #####:  931:    int maxArtistLen = 36;
    #####:  932:    std::string title = m_state.currentTrackTitle.empty() ? "No track playing" : m_state.currentTrackTitle;
    #####:  933:    if (title.length() > static_cast<size_t>(maxTitleLen)) title = title.substr(0, maxTitleLen - 3) + "...";
    #####:  934:    std::string artist = m_state.currentTrackArtist.empty() ? "" : m_state.currentTrackArtist;
    #####:  935:    if (artist.length() > static_cast<size_t>(maxArtistLen)) artist = artist.substr(0, maxArtistLen - 3) + "...";
        -:  936:    
    #####:  937:    drawText(title, infoX, y + 25, m_theme.textPrimary, 16);
    #####:  938:    if (!artist.empty()) {
    #####:  939:        drawText(artist, infoX, y + 48, m_theme.textSecondary, 12);
        -:  940:    }
        -:  941:    
        -:  942:    // Playback controls (center)
    #####:  943:    int controlsX = m_width / 2 - 70;
    #####:  944:    int controlsY = y + 15;
        -:  945:    
        -:  946:    // Previous button
    #####:  947:    bool prevHover = isMouseOver(controlsX, controlsY, 35, 35);
    #####:  948:    drawRect(controlsX, controlsY, 35, 35, prevHover ? m_theme.surfaceHover : m_theme.surface);
    #####:  949:    drawText("|<", controlsX + 8, controlsY + 8, prevHover ? m_theme.textPrimary : m_theme.textSecondary, 16);
    #####:  950:    if (prevHover && m_mouseClicked && m_playbackController) {
    #####:  951:        m_playbackController->playPrevious();
        -:  952:    }
        -:  953:    
        -:  954:    // Play/Pause button
    #####:  955:    int playX = controlsX + 45;
    #####:  956:    bool playHover = isMouseOver(playX, controlsY, 40, 40);
    #####:  957:    drawRect(playX, controlsY, 40, 40, playHover ? m_theme.primaryHover : m_theme.primary, true);
    #####:  958:    const char* playIcon = m_state.isPlaying ? "||" : ">";
    #####:  959:    drawText(playIcon, playX + 12, controlsY + 8, m_theme.textPrimary, 20);
        -:  960:    
    #####:  961:    if (playHover && m_mouseClicked && m_playbackController) {
    #####:  962:        if (m_state.isPlaying) {
    #####:  963:            m_playbackController->pause();
    #####:  964:            m_state.isPlaying = false;
        -:  965:        } else {
    #####:  966:            m_playbackController->play();
    #####:  967:            m_state.isPlaying = true;
        -:  968:        }
        -:  969:    }
        -:  970:    
        -:  971:    // Next button  
    #####:  972:    int nextX = controlsX + 100;
    #####:  973:    bool nextHover = isMouseOver(nextX, controlsY, 35, 35);
    #####:  974:    drawRect(nextX, controlsY, 35, 35, nextHover ? m_theme.surfaceHover : m_theme.surface);
    #####:  975:    drawText(">|", nextX + 8, controlsY + 8, nextHover ? m_theme.textPrimary : m_theme.textSecondary, 16);
    #####:  976:    if (nextHover && m_mouseClicked && m_playbackController) {
    #####:  977:        m_playbackController->playNext();
        -:  978:    }
        -:  979:    
        -:  980:    // Progress bar
    #####:  981:    int progressX = m_width / 2 - 150;
    #####:  982:    int progressY = y + 55;
    #####:  983:    int progressW = 300;
    #####:  984:    int progressH = 6;
        -:  985:    
        -:  986:    // Time labels
    #####:  987:    std::string currentTime = "0:00";
    #####:  988:    std::string totalTime = "0:00";
        -:  989:    
    #####:  990:    if (m_state.playbackDuration > 0) {
    #####:  991:        int currentSec = static_cast<int>(m_state.playbackProgress * m_state.playbackDuration);
    #####:  992:        int totalSec = static_cast<int>(m_state.playbackDuration);
        -:  993:        
    #####:  994:        std::ostringstream currentSS, totalSS;
    #####:  995:        currentSS << (currentSec / 60) << ":" << std::setfill('0') << std::setw(2) << (currentSec % 60);
    #####:  996:        totalSS << (totalSec / 60) << ":" << std::setfill('0') << std::setw(2) << (totalSec % 60);
    #####:  997:        currentTime = currentSS.str();
    #####:  998:        totalTime = totalSS.str();
    #####:  999:    }
        -: 1000:    
    #####: 1001:    drawText(currentTime, progressX - 45, progressY - 3, m_theme.textDim, 11);
    #####: 1002:    drawProgressBar(progressX, progressY, progressW, progressH, m_state.playbackProgress, 
        -: 1003:                    m_theme.primary, m_theme.scrollbar);
    #####: 1004:    drawText(totalTime, progressX + progressW + 10, progressY - 3, m_theme.textDim, 11);
        -: 1005:    
        -: 1006:    // Handle progress bar click for seeking
    #####: 1007:    if (isMouseOver(progressX, progressY - 5, progressW, progressH + 10) && m_mouseClicked) {
    #####: 1008:        float seekPos = static_cast<float>(m_mouseX - progressX) / progressW;
    #####: 1009:        seekPos = std::clamp(seekPos, 0.0f, 1.0f);
    #####: 1010:        m_state.playbackProgress = seekPos;
    #####: 1011:        if (m_playbackController && m_state.playbackDuration > 0) {
    #####: 1012:            int seekSeconds = static_cast<int>(seekPos * m_state.playbackDuration);
    #####: 1013:            m_playbackController->seek(seekSeconds);
        -: 1014:        }
        -: 1015:    }
        -: 1016:    
        -: 1017:    // Volume control (right side)
    #####: 1018:    int volumeX = m_width - 180;
    #####: 1019:    int volumeY = y + 35;
        -: 1020:    
    #####: 1021:    drawText("Vol:", volumeX - 5, volumeY, m_theme.textSecondary, 12);
        -: 1022:    
    #####: 1023:    int sliderX = volumeX + 30;
    #####: 1024:    int sliderW = 100;
    #####: 1025:    int sliderH = 6;
        -: 1026:    
    #####: 1027:    drawRect(sliderX, volumeY + 5, sliderW, sliderH, m_theme.scrollbar);
    #####: 1028:    int volumeW = static_cast<int>(sliderW * m_state.volume);
    #####: 1029:    drawRect(sliderX, volumeY + 5, volumeW, sliderH, m_theme.primary);
        -: 1030:    
        -: 1031:    // Volume knob
    #####: 1032:    int knobX = sliderX + volumeW - 4;
    #####: 1033:    drawRect(knobX, volumeY + 2, 8, 12, m_theme.textPrimary, true);
        -: 1034:    
        -: 1035:    // Handle volume drag
    #####: 1036:    if (isMouseOver(sliderX, volumeY, sliderW, 20) && m_mouseDown) {
    #####: 1037:        float newVolume = static_cast<float>(m_mouseX - sliderX) / sliderW;
    #####: 1038:        m_state.volume = std::clamp(newVolume, 0.0f, 1.0f);
    #####: 1039:        if (m_onVolumeChange) {
    #####: 1040:            m_onVolumeChange(m_state.volume);
        -: 1041:        }
        -: 1042:    }
        -: 1043:    
        -: 1044:    // Loop / Shuffle buttons (larger hit area so they register reliably)
    #####: 1045:    int modeX = volumeX - 80;
    #####: 1046:    const int modeBtnW = 28;
    #####: 1047:    const int modeBtnH = 28;
        -: 1048:    
        -: 1049:    // Shuffle
    #####: 1050:    bool shuffleHover = isMouseOver(modeX, volumeY - 2, modeBtnW, modeBtnH);
    #####: 1051:    uint32_t shuffleColor = m_state.shuffleEnabled ? m_theme.primary : (shuffleHover ? m_theme.textPrimary : m_theme.textDim);
    #####: 1052:    drawText("S", modeX + 8, volumeY + 2, shuffleColor, 14);
    #####: 1053:    if (shuffleHover && m_mouseClicked && m_queueController) {
    #####: 1054:        m_queueController->toggleShuffle();
    #####: 1055:        m_state.shuffleEnabled = m_queueController->isShuffleEnabled();
    #####: 1056:        m_mouseClicked = false;
        -: 1057:    }
        -: 1058:    
        -: 1059:    // Loop (cycles: None -> LoopOne -> LoopAll -> None)
    #####: 1060:    int loopX = modeX + 34;
    #####: 1061:    bool loopHover = isMouseOver(loopX, volumeY - 2, modeBtnW, modeBtnH);
    #####: 1062:    uint32_t loopColor = m_state.loopEnabled ? m_theme.primary : (loopHover ? m_theme.textPrimary : m_theme.textDim);
    #####: 1063:    const char* loopLabel = m_state.loopAllEnabled ? "L+" : "L";
    #####: 1064:    drawText(loopLabel, loopX + (m_state.loopAllEnabled ? 4 : 8), volumeY + 2, loopColor, 14);
    #####: 1065:    if (loopHover && m_mouseClicked && m_queueController) {
    #####: 1066:        m_queueController->cycleRepeatMode();
    #####: 1067:        m_state.loopEnabled = m_queueController->isRepeatEnabled();
    #####: 1068:        m_state.loopAllEnabled = m_queueController->isLoopAllEnabled();
    #####: 1069:        m_mouseClicked = false;
        -: 1070:    }
        -: 1071:    
        -: 1072:    // Hardware connection status indicator removed as per user request
    #####: 1073:}
        -: 1074:
    #####: 1075:void ImGuiManager::renderQueuePanel() {
    #####: 1076:    int x = SIDEBAR_WIDTH + 10;
    #####: 1077:    int y = MENU_BAR_HEIGHT + 10;
    #####: 1078:    int w = m_width - SIDEBAR_WIDTH - 20;
        -: 1079:    
        -: 1080:    // Header
    #####: 1081:    std::string headerText = "Queue";
    #####: 1082:    if (m_queueController) {
    #####: 1083:        headerText += " (" + std::to_string(m_queueController->getQueueSize()) + " items)";
        -: 1084:    }
    #####: 1085:    drawText(headerText, x, y, m_theme.textPrimary, 20);
        -: 1086:    
        -: 1087:    // Clear Queue Button (if not empty)
    #####: 1088:    if (m_queueController && !m_queueController->isEmpty()) {
    #####: 1089:        int clearBtnW = 100;
    #####: 1090:        if (isMouseOver(x + w - clearBtnW, y, clearBtnW, 25)) {
    #####: 1091:            drawRect(x + w - clearBtnW, y, clearBtnW, 25, m_theme.surfaceHover);
    #####: 1092:            if (m_mouseClicked) {
    #####: 1093:                m_queueController->clearQueue();
        -: 1094:            }
        -: 1095:        } else {
    #####: 1096:            drawRect(x + w - clearBtnW, y, clearBtnW, 25, m_theme.surface);
        -: 1097:        }
    #####: 1098:        drawText("Clear Queue", x + w - clearBtnW + 10, y + 5, m_theme.textDim, 12);
        -: 1099:    }
        -: 1100:
    #####: 1101:    y += 40;
        -: 1102:    
        -: 1103:    // Now Playing section
    #####: 1104:    drawText("Now Playing", x, y, m_theme.textSecondary, 14);
    #####: 1105:    y += 25;
        -: 1106:    
    #####: 1107:    drawRect(x, y, w, 60, m_theme.surface);
    #####: 1108:    if (!m_state.currentTrackTitle.empty()) {
    #####: 1109:        int npArtSize = 40;
    #####: 1110:        drawRect(x + 10, y + 10, npArtSize, npArtSize, m_theme.surfaceHover);
    #####: 1111:        drawText("~", x + 23, y + 20, m_theme.textDim, 20); // Placeholder art
        -: 1112:        
    #####: 1113:        drawText(m_state.currentTrackTitle, x + 60, y + 12, m_theme.primary, 16);
    #####: 1114:        drawText(m_state.currentTrackArtist, x + 60, y + 35, m_theme.textSecondary, 12);
        -: 1115:    } else {
    #####: 1116:        drawText("No track playing", x + 20, y + 20, m_theme.textDim, 14);
        -: 1117:    }
    #####: 1118:    y += 80;
        -: 1119:    
        -: 1120:    // Up Next section
    #####: 1121:    drawText("Up Next", x, y, m_theme.textSecondary, 14);
    #####: 1122:    y += 25;
        -: 1123:    
    #####: 1124:    if (!m_queueController || m_queueController->isEmpty()) {
        -: 1125:        // Queue is empty message
    #####: 1126:        drawRect(x, y, w, 100, m_theme.surface);
    #####: 1127:        drawText("Queue is empty", x + 20, y + 40, m_theme.textDim, 14);
    #####: 1128:        drawText("Play a song from Library to start", x + 20, y + 60, m_theme.textDim, 12);
        -: 1129:    } else {
        -: 1130:        // Queue List (playback order when shuffle on)
    #####: 1131:        auto queueItems = m_queueController->getPlaybackOrderItems();
    #####: 1132:        size_t currentLogicalIndex = m_queueController->getCurrentIndex();
    #####: 1133:        int listH = m_height - y - PLAYER_BAR_HEIGHT - 20;
        -: 1134:        
        -: 1135:        // Items to display
        -: 1136:        // Calculate visible area for scrolling
        -: 1137:        
        -: 1138:        // Clip rect for list
    #####: 1139:        SDL_Rect clipRect = { x, y, w, listH };
    #####: 1140:        SDL_RenderSetClipRect(m_renderer, &clipRect);
        -: 1141:        
        -: 1142:        // Scrollable content height
        -: 1143:        // int totalContentH = queueItems.size() * ITEM_HEIGHT;
        -: 1144:        
    #####: 1145:        for (size_t i = 0; i < queueItems.size(); i++) {
    #####: 1146:            const auto& media = queueItems[i];
        -: 1147:            
        -: 1148:            // Calculate Y with scroll offset
    #####: 1149:            int itemY = y + (i * ITEM_HEIGHT) - m_state.queueScrollOffset;
        -: 1150:            
        -: 1151:            // Culling
    #####: 1152:            if (itemY + ITEM_HEIGHT < y || itemY > y + listH) continue;
        -: 1153:            
    #####: 1154:            bool hover = isMouseOver(x, itemY, w, ITEM_HEIGHT);
        -: 1155:            // Check if mouse inside List Area
    #####: 1156:            bool mouseInList = isMouseOver(x, y, w, listH);
    #####: 1157:            hover = hover && mouseInList;
        -: 1158:            
    #####: 1159:            drawRect(x, itemY, w, ITEM_HEIGHT, hover ? m_theme.surfaceHover : (i % 2 == 0 ? m_theme.background : m_theme.surface));
        -: 1160:            
        -: 1161:            // Context Menu (Right Click)
        -: 1162:            int mx, my;
    #####: 1163:            uint32_t buttons = SDL_GetMouseState(&mx, &my);
    #####: 1164:            if (hover && mouseInList && (buttons & SDL_BUTTON(SDL_BUTTON_RIGHT))) {
    #####: 1165:                 m_state.showContextMenu = true;
    #####: 1166:                 m_state.contextMenuX = mx;
    #####: 1167:                 m_state.contextMenuY = my;
    #####: 1168:                 m_state.contextMediaItem = media;
    #####: 1169:                 m_state.contextMenuSource = ui::ContextMenuSource::Queue;
        -: 1170:            }
        -: 1171:            
        -: 1172:            // Index (position in playback order)
    #####: 1173:            bool isCurrent = (m_state.isPlaying && static_cast<size_t>(i) == currentLogicalIndex);
    #####: 1174:            std::string marker = isCurrent ? "> " : "";
    #####: 1175:            drawText(marker + std::to_string(i + 1), x + 10, itemY + 15, m_theme.textDim, 12);
        -: 1176:            
        -: 1177:            // Title
    #####: 1178:            std::string title = media.getTitle().empty() ? media.getFileName() : media.getTitle();
    #####: 1179:            if (title.length() > 50) title = title.substr(0, 47) + "...";
    #####: 1180:            uint32_t titleColor = isCurrent ? m_theme.success : m_theme.textPrimary;
    #####: 1181:            drawText(title, x + 40, itemY + 15, titleColor, 14);
        -: 1182:            
        -: 1183:            // Artist
    #####: 1184:            std::string artist = media.getArtist();
    #####: 1185:            if (artist.length() > 30) artist = artist.substr(0, 27) + "...";
    #####: 1186:            if (!artist.empty()) {
    #####: 1187:                drawText(artist, x + w / 2, itemY + 15, m_theme.textSecondary, 12);
        -: 1188:            }
        -: 1189:            
        -: 1190:            // Duration
    #####: 1191:            int duration = media.getDuration();
    #####: 1192:            if (duration > 0) {
    #####: 1193:                int mins = duration / 60;
    #####: 1194:                int secs = duration % 60;
    #####: 1195:                std::string timeStr = std::to_string(mins) + ":" + (secs < 10 ? "0" : "") + std::to_string(secs);
    #####: 1196:                drawText(timeStr, x + w - 80, itemY + 15, m_theme.textDim, 12);
    #####: 1197:            }
        -: 1198:            
        -: 1199:            // Remove button (right side)
    #####: 1200:            int removeBtnX = x + w - 30;
    #####: 1201:            if (isMouseOver(removeBtnX, itemY + 5, 20, 20) && mouseInList) {
    #####: 1202:                drawText("x", removeBtnX + 6, itemY + 14, m_theme.primaryHover, 14);
    #####: 1203:                if (m_mouseClicked && !m_state.showContextMenu && !m_state.showAddToPlaylistDialog && !m_state.showPropertiesDialog) {
    #####: 1204:                    m_queueController->removeByPath(media.getFilePath());
    #####: 1205:                    break;
        -: 1206:                }
        -: 1207:            } else {
    #####: 1208:                if (hover) drawText("x", removeBtnX + 6, itemY + 14, m_theme.textDim, 14);
        -: 1209:            }
        -: 1210:            
        -: 1211:            // Click to Play (Jump to this item)
        -: 1212:            // Left click on item (not remove btn)
    #####: 1213:            if (hover && m_mouseClicked && m_mouseX < removeBtnX && !m_state.showContextMenu && !m_state.showAddToPlaylistDialog && !m_state.showPropertiesDialog) {
    #####: 1214:                 if (m_playbackController) {
    #####: 1215:                     m_playbackController->playItemAt(i);
        -: 1216:                     
        -: 1217:                     // Cập nhật UI state trực tiếp để tránh delay 1 frame
    #####: 1218:                     std::string title = media.getTitle().empty() ? media.getFileName() : media.getTitle();
    #####: 1219:                     std::string artist = media.getArtist().empty() ? "Unknown Artist" : media.getArtist();
    #####: 1220:                     m_state.currentTrackTitle = title;
    #####: 1221:                     m_state.currentTrackArtist = artist;
    #####: 1222:                     m_state.isPlaying = true;
        -: 1223:                     
    #####: 1224:                     m_mouseClicked = false;
    #####: 1225:                 }
        -: 1226:            }
    #####: 1227:        }
        -: 1228:        
    #####: 1229:        SDL_RenderSetClipRect(m_renderer, nullptr);
    #####: 1230:    }
    #####: 1231:}
        -: 1232:
    #####: 1233:void ImGuiManager::renderPlaylistPanel() {
    #####: 1234:    int x = SIDEBAR_WIDTH + 10;
    #####: 1235:    int y = MENU_BAR_HEIGHT + 10;
    #####: 1236:    int w = m_width - SIDEBAR_WIDTH - 20;
        -: 1237:    
        -: 1238:    // Header
    #####: 1239:    drawText("Playlists", x, y, m_theme.textPrimary, 20);
    #####: 1240:    y += 40;
        -: 1241:    
        -: 1242:    // New Playlist button
    #####: 1243:    int btnW = 150;
    #####: 1244:    int btnH = 35;
    #####: 1245:    bool btnHover = isMouseOver(x, y, btnW, btnH);
    #####: 1246:    drawRect(x, y, btnW, btnH, btnHover ? m_theme.primaryHover : m_theme.primary);
    #####: 1247:    drawText("+ New Playlist", x + 15, y + 9, m_theme.textPrimary, 14);
    #####: 1248:    y += 50;
        -: 1249:    
        -: 1250:    // Playlist list section
    #####: 1251:    if (m_state.showCreatePlaylistDialog) {
        -: 1252:        // Dialog Overlay
    #####: 1253:        drawRect(x + w/2 - 150, y, 300, 150, m_theme.surface);
    #####: 1254:        drawRect(x + w/2 - 150, y, 300, 150, m_theme.border, false); // Border
        -: 1255:        
    #####: 1256:        drawText("Create New Playlist", x + w/2 - 130, y + 20, m_theme.textPrimary, 16);
        -: 1257:        
        -: 1258:        // Input box
    #####: 1259:        drawRect(x + w/2 - 130, y + 50, 260, 30, m_theme.background);
    #####: 1260:        drawText(m_state.newPlaylistName.empty() ? "Enter name..." : m_state.newPlaylistName, 
    #####: 1261:                 x + w/2 - 120, y + 58, m_theme.textPrimary, 14);
        -: 1262:        // Cursor
    #####: 1263:        if (SDL_GetTicks() % 1000 < 500) {
    #####: 1264:            int textW = m_state.newPlaylistName.length() * 8; // Approx width
    #####: 1265:            drawRect(x + w/2 - 120 + textW, y + 55, 2, 20, m_theme.textPrimary);
        -: 1266:        }
        -: 1267:        
        -: 1268:        // Buttons
        -: 1269:        // Create
    #####: 1270:        bool createHover = isMouseOver(x + w/2 + 20, y + 100, 100, 30);
    #####: 1271:        drawRect(x + w/2 + 20, y + 100, 100, 30, createHover ? m_theme.primaryHover : m_theme.primary);
    #####: 1272:        drawText("Create", x + w/2 + 45, y + 107, m_theme.textPrimary, 14);
    #####: 1273:        if (createHover && m_mouseClicked && !m_state.newPlaylistName.empty() && m_playlistController) {
    #####: 1274:            m_playlistController->createPlaylist(m_state.newPlaylistName);
    #####: 1275:            m_state.showCreatePlaylistDialog = false;
    #####: 1276:            m_state.newPlaylistName.clear();
    #####: 1277:            SDL_StopTextInput();
    #####: 1278:            m_mouseClicked = false; // Consume click
        -: 1279:        }
        -: 1280:        
        -: 1281:        // Cancel
    #####: 1282:        bool cancelHover = isMouseOver(x + w/2 - 120, y + 100, 100, 30);
    #####: 1283:        drawRect(x + w/2 - 120, y + 100, 100, 30, cancelHover ? m_theme.surfaceHover : m_theme.surfaceActive);
    #####: 1284:        drawText("Cancel", x + w/2 - 95, y + 107, m_theme.textPrimary, 14);
    #####: 1285:        if (cancelHover && m_mouseClicked) {
    #####: 1286:            m_state.showCreatePlaylistDialog = false;
    #####: 1287:            m_state.newPlaylistName.clear();
    #####: 1288:            SDL_StopTextInput();
    #####: 1289:            m_mouseClicked = false;
        -: 1290:        }
        -: 1291:        
    #####: 1292:        return; // Don't match clicks below
        -: 1293:    } else {
        -: 1294:        // Handle "New Playlist" button click from header (simulated here for flow)
    #####: 1295:        if (isMouseOver(x, y - 50, 150, 35) && m_mouseClicked) {
    #####: 1296:             m_state.showCreatePlaylistDialog = true;
    #####: 1297:             SDL_StartTextInput();
    #####: 1298:             m_mouseClicked = false;
        -: 1299:        }
        -: 1300:    }
        -: 1301:    
    #####: 1302:    if (m_playlistController) {
    #####: 1303:        if (!m_state.selectedPlaylistId.empty()) {
    #####: 1304:            auto playlistOpt = m_playlistController->getPlaylistById(m_state.selectedPlaylistId);
    #####: 1305:            if (!playlistOpt) {
    #####: 1306:                m_state.selectedPlaylistId.clear(); // Playlist deleted?
    #####: 1307:                return;
        -: 1308:            }
    #####: 1309:            const auto& playlist = *playlistOpt;
        -: 1310:            
        -: 1311:            // Header: < Back | Playlist Name | Rename
    #####: 1312:            if (isMouseOver(x, y, 60, 30)) {
    #####: 1313:                drawRect(x, y, 60, 30, m_theme.surfaceHover);
    #####: 1314:                if (m_mouseClicked) {
    #####: 1315:                    m_state.selectedPlaylistId.clear();
    #####: 1316:                    m_mouseClicked = false;
    #####: 1317:                    return;
        -: 1318:                }
        -: 1319:            }
    #####: 1320:            drawText("< Back", x + 10, y + 8, m_theme.textPrimary, 14);
        -: 1321:            
    #####: 1322:            drawText(playlist.getName(), x + 80, y + 5, m_theme.textPrimary, 20);
        -: 1323:            
        -: 1324:            // Rename Button
    #####: 1325:            int renameX = x + w - 80;
    #####: 1326:            if (isMouseOver(renameX, y, 80, 30)) {
    #####: 1327:                drawRect(renameX, y, 80, 30, m_theme.surfaceHover);
    #####: 1328:                if (m_mouseClicked) {
        -: 1329:                    // Trigger rename dialog
    #####: 1330:                    m_state.showRenamePlaylistDialog = true;
    #####: 1331:                    m_state.renamePlaylistId = playlist.getId();
    #####: 1332:                    m_state.renamePlaylistName = playlist.getName();
    #####: 1333:                    SDL_StartTextInput();
    #####: 1334:                    m_mouseClicked = false;
        -: 1335:                }
        -: 1336:            }
    #####: 1337:            drawText("Rename", renameX + 15, y + 8, m_theme.textPrimary, 12);
        -: 1338:            
    #####: 1339:            y += 50;
        -: 1340:            
        -: 1341:            // List Items
    #####: 1342:            const auto& items = playlist.getItems();
    #####: 1343:            if (items.empty()) {
    #####: 1344:                drawText("Playlist is empty. Add songs from Library.", x, y + 20, m_theme.textDim, 14);
        -: 1345:            }
        -: 1346:            
    #####: 1347:            int itemY = y;
    #####: 1348:            for (size_t i = 0; i < items.size(); ++i) {
    #####: 1349:                if (itemY > m_height - PLAYER_BAR_HEIGHT - 40) break; // Clip
    #####: 1350:                const auto& media = items[i];
        -: 1351:                
    #####: 1352:                bool hover = isMouseOver(x, itemY, w, ITEM_HEIGHT);
    #####: 1353:                bool fileExists = std::filesystem::exists(media.getFilePath());
    #####: 1354:                uint32_t bg = (i % 2 == 0) ? m_theme.background : m_theme.surface;
    #####: 1355:                if (hover) bg = m_theme.surfaceHover;
        -: 1356:                
    #####: 1357:                drawRect(x, itemY, w, ITEM_HEIGHT, bg);
        -: 1358:                
    #####: 1359:                drawText(std::to_string(i+1) + ".", x + 10, itemY + 15, m_theme.textSecondary, 12);
        -: 1360:                
    #####: 1361:                std::string title = media.getTitle().empty() ? media.getFileName() : media.getTitle();
    #####: 1362:                if (!fileExists) title += " (file not found)";
    #####: 1363:                if (title.length() > 40) title = title.substr(0, 37) + "...";
    #####: 1364:                uint32_t titleColor = fileExists ? m_theme.textPrimary : m_theme.textDim;
    #####: 1365:                drawText(title, x + 40, itemY + 15, titleColor, 14);
        -: 1366:                
        -: 1367:                // Context Menu (Right Click)
        -: 1368:                int mx, my;
    #####: 1369:                uint32_t buttons = SDL_GetMouseState(&mx, &my);
    #####: 1370:                if (hover && (buttons & SDL_BUTTON(SDL_BUTTON_RIGHT))) {
    #####: 1371:                     m_state.showContextMenu = true;
    #####: 1372:                     m_state.contextMenuX = mx;
    #####: 1373:                     m_state.contextMenuY = my;
    #####: 1374:                     m_state.contextMediaItem = media;
    #####: 1375:                     m_state.contextMenuSource = ui::ContextMenuSource::Playlist;
        -: 1376:                }
        -: 1377:
        -: 1378:                // Play Button (Double click or icon?)
        -: 1379:                // Click to play (Left Click)
    #####: 1380:                if (hover && m_mouseClicked && !m_state.showContextMenu && !m_state.showAddToPlaylistDialog && !m_state.showPropertiesDialog && !m_state.showRenamePlaylistDialog && m_mouseX < x + w - 40 && !(buttons & SDL_BUTTON(SDL_BUTTON_RIGHT))) {
        -: 1381:                    // Check if file exists before attempting to play
    #####: 1382:                    if (fileExists) {
        -: 1383:                        // Play this item OR play whole playlist starting here?
        -: 1384:                        // Standard logic: Play playlist starting at index.
        -: 1385:                        // Need QueueController->addPlaylistToQueue(playlist) then play index?
        -: 1386:                        // Or Replace Queue with Playlist?
        -: 1387:                        // Let's just Add item to queue and play for now.
    #####: 1388:                        if (m_queueController && m_playbackController) {
        -: 1389:                            // Clear queue and play playlist? Or just append?
        -: 1390:                            // Usually "Play Playlist" replaces queue.
    #####: 1391:                            m_queueController->clearQueue();
    #####: 1392:                            m_queueController->addPlaylistToQueue(playlist);
    #####: 1393:                            m_queueController->jumpToIndex(i); 
    #####: 1394:                            m_playbackController->play(); 
        -: 1395:                        }
        -: 1396:                    }
        -: 1397:                    // File doesn't exist - do nothing (visual feedback already shown)
    #####: 1398:                    m_mouseClicked = false;
        -: 1399:                }
        -: 1400:                
        -: 1401:                // Remove Button
    #####: 1402:                int remX = x + w - 30;
    #####: 1403:                if (isMouseOver(remX, itemY + 5, 20, 20)) {
    #####: 1404:                    drawText("x", remX + 6, itemY + 14, m_theme.error, 14);
    #####: 1405:                    if (m_mouseClicked && !m_state.showContextMenu && !m_state.showAddToPlaylistDialog && !m_state.showRenamePlaylistDialog) {
    #####: 1406:                        m_playlistController->removeMediaFromPlaylist(playlist.getId(), i);
    #####: 1407:                        break; // List modified
        -: 1408:                    }
    #####: 1409:                } else if (hover) {
    #####: 1410:                    drawText("x", remX + 6, itemY + 14, m_theme.textDim, 14);
        -: 1411:                }
        -: 1412:                
    #####: 1413:                itemY += ITEM_HEIGHT;
    #####: 1414:            }
        -: 1415:            
    #####: 1416:        } else {
        -: 1417:            // LIST VIEW
    #####: 1418:            auto playlists = m_playlistController->getAllPlaylists();
        -: 1419:            
    #####: 1420:            int itemY = y;
    #####: 1421:            for (const auto& playlist : playlists) {
    #####: 1422:                bool hover = isMouseOver(x, itemY, w, ITEM_HEIGHT);
        -: 1423:                
    #####: 1424:                drawRect(x, itemY, w, ITEM_HEIGHT, hover ? m_theme.surfaceHover : m_theme.surface);
    #####: 1425:                drawText("#", x + 15, itemY + 15, m_theme.primary, 14);
    #####: 1426:                drawText(playlist.getName(), x + 40, itemY + 15, m_theme.textPrimary, 14);
        -: 1427:                
    #####: 1428:                std::string countStr = std::to_string(playlist.getItemCount()) + " tracks";
    #####: 1429:                drawText(countStr, x + w - 100, itemY + 15, m_theme.textDim, 12);
        -: 1430:                
        -: 1431:                // Click to Enter Detail View (if not clicking delete)
    #####: 1432:                if (hover && m_mouseClicked && m_mouseX < x + w - 40) {
    #####: 1433:                    m_state.selectedPlaylistId = playlist.getId();
    #####: 1434:                    m_mouseClicked = false;
        -: 1435:                }
        -: 1436:                
        -: 1437:                // Delete button
    #####: 1438:                int delX = x + w - 30;
    #####: 1439:                if (isMouseOver(delX, itemY + 5, 20, 20)) {
    #####: 1440:                     drawText("x", delX + 6, itemY + 14, m_theme.primaryHover, 14);
    #####: 1441:                     if (m_mouseClicked) {
    #####: 1442:                         m_playlistController->deletePlaylist(playlist.getId());
    #####: 1443:                         break; // Modifying list
        -: 1444:                     }
        -: 1445:                } else {
    #####: 1446:                     if (hover) drawText("x", delX + 6, itemY + 14, m_theme.textDim, 14);
        -: 1447:                }
        -: 1448:                
    #####: 1449:                itemY += ITEM_HEIGHT + 5;
    #####: 1450:            }
    #####: 1451:        }
        -: 1452:    }
        -: 1453:}
        -: 1454:
    #####: 1455:void ImGuiManager::renderHistoryPanel() {
    #####: 1456:    int x = SIDEBAR_WIDTH + 10;
    #####: 1457:    int y = MENU_BAR_HEIGHT + 10;
    #####: 1458:    int w = m_width - SIDEBAR_WIDTH - 20;
        -: 1459:    
        -: 1460:    // Header
    #####: 1461:    drawText("History", x, y, m_theme.textPrimary, 20);
    #####: 1462:    y += 40;
        -: 1463:    
        -: 1464:    // Recently Played section
    #####: 1465:    drawText("Recently Played", x, y, m_theme.textSecondary, 14);
    #####: 1466:    y += 25;
        -: 1467:    
        -: 1468:    // Check if we have history
    #####: 1469:    if (m_state.currentTrackTitle.empty()) {
    #####: 1470:        drawRect(x, y, w, 100, m_theme.surface);
    #####: 1471:        drawText("No playback history yet", x + 20, y + 40, m_theme.textDim, 14);
    #####: 1472:        drawText("Play some tracks to see them here", x + 20, y + 60, m_theme.textDim, 12);
        -: 1473:    } else {
        -: 1474:        // Show current/last played track
    #####: 1475:        drawRect(x, y, w, 60, m_theme.surface);
    #####: 1476:        drawText(">", x + 15, y + 18, m_theme.success, 18);
    #####: 1477:        drawText(m_state.currentTrackTitle, x + 50, y + 12, m_theme.textPrimary, 16);
    #####: 1478:        drawText(m_state.currentTrackArtist, x + 50, y + 35, m_theme.textSecondary, 12);
    #####: 1479:        drawText("Now Playing", x + w - 100, y + 20, m_theme.success, 12);
    #####: 1480:        y += 70;
        -: 1481:    }
        -: 1482:    
        -: 1483:    // History List (with scroll - supports up to 100 items)
    #####: 1484:    if (!m_historyList.empty()) {
    #####: 1485:        int listAreaH = m_height - MENU_BAR_HEIGHT - PLAYER_BAR_HEIGHT - y - 20;
    #####: 1486:        int maxScroll = std::max(0, static_cast<int>(m_historyList.size() * ITEM_HEIGHT) - listAreaH);
    #####: 1487:        if (m_state.historyScrollOffset > maxScroll) m_state.historyScrollOffset = maxScroll;
        -: 1488:        
    #####: 1489:        SDL_Rect listClip = {x, y, w, listAreaH};
    #####: 1490:        SDL_RenderSetClipRect(m_renderer, &listClip);
        -: 1491:        
    #####: 1492:        int itemY = y - m_state.historyScrollOffset;
    #####: 1493:        int index = 0;
        -: 1494:        
    #####: 1495:        for (const auto& entry : m_historyList) {
    #####: 1496:            if (itemY + ITEM_HEIGHT < y || itemY > m_height - PLAYER_BAR_HEIGHT - 20) {
    #####: 1497:                itemY += ITEM_HEIGHT;
    #####: 1498:                index++;
    #####: 1499:                continue;
        -: 1500:            }
        -: 1501:            
    #####: 1502:            bool mouseInList = isMouseOver(x, y, w, listAreaH);
    #####: 1503:            bool hover = mouseInList && isMouseOver(x, itemY, w, ITEM_HEIGHT);
        -: 1504:             
        -: 1505:             // Alternating background
    #####: 1506:            uint32_t bg = (index % 2 == 0) ? m_theme.background : m_theme.surface;
    #####: 1507:            if (hover) bg = m_theme.surfaceHover;
        -: 1508:            
    #####: 1509:            drawRect(x, itemY, w, ITEM_HEIGHT, bg);
        -: 1510:            
        -: 1511:            // Serial number (1-based)
    #####: 1512:            drawText(std::to_string(index + 1), x + 15, itemY + 15, m_theme.textDim, 14);
        -: 1513:            
    #####: 1514:            bool fileExists = std::filesystem::exists(entry.media.getFilePath());
    #####: 1515:            std::string title = entry.media.getTitle().empty() ? entry.media.getFileName() : entry.media.getTitle();
    #####: 1516:            if (!fileExists) title += " (file not found)";
    #####: 1517:            if (title.length() > 50) title = title.substr(0, 47) + "...";
    #####: 1518:            uint32_t titleColor = fileExists ? m_theme.textPrimary : m_theme.textDim;
    #####: 1519:            drawText(title, x + 50, itemY + 15, titleColor, 14);
        -: 1520:            
    #####: 1521:            std::string artist = entry.media.getArtist();
    #####: 1522:            if (!artist.empty()) drawText(artist, x + w / 2, itemY + 15, fileExists ? m_theme.textSecondary : m_theme.textDim, 14);
        -: 1523:            
        -: 1524:            // Context Menu (Right Click)
        -: 1525:            int mx, my;
    #####: 1526:            uint32_t buttons = SDL_GetMouseState(&mx, &my);
    #####: 1527:            if (hover && (buttons & SDL_BUTTON(SDL_BUTTON_RIGHT))) {
    #####: 1528:                 m_state.showContextMenu = true;
    #####: 1529:                 m_state.contextMenuX = mx;
    #####: 1530:                 m_state.contextMenuY = my;
    #####: 1531:                 m_state.contextMediaItem = entry.media;
    #####: 1532:                 m_state.contextMenuSource = ui::ContextMenuSource::Queue;
        -: 1533:            }
        -: 1534:            
        -: 1535:            // Click to Play (Left Click only)
    #####: 1536:             if (hover && m_mouseClicked && !m_state.showContextMenu && !m_state.showAddToPlaylistDialog && !m_state.showPropertiesDialog && m_queueController && m_playbackController && !(buttons & SDL_BUTTON(SDL_BUTTON_RIGHT))) {
    #####: 1537:                m_queueController->addToQueue(entry.media);
        -: 1538:                // Play the newly added item (at the end)
    #####: 1539:                if (m_queueController->getQueueSize() > 0) {
    #####: 1540:                     size_t newIndex = m_queueController->getQueueSize() - 1;
    #####: 1541:                     m_playbackController->playItemAt(newIndex);
        -: 1542:                }
    #####: 1543:                 m_mouseClicked = false;
        -: 1544:             }
        -: 1545:
    #####: 1546:            itemY += ITEM_HEIGHT;
    #####: 1547:            index++;
    #####: 1548:        }
        -: 1549:        
    #####: 1550:        SDL_RenderSetClipRect(m_renderer, nullptr);
        -: 1551:    } else {
    #####: 1552:        drawText("No history available.", x, y + 20, m_theme.textDim, 14);
        -: 1553:    }
    #####: 1554:}
        -: 1555:
    #####: 1556:void ImGuiManager::renderScanProgress(const std::string& path, int current, int total) {
    #####: 1557:    int boxW = 450;
    #####: 1558:    int boxH = 170;
    #####: 1559:    int boxX = (m_width - boxW) / 2;
    #####: 1560:    int boxY = (m_height - boxH) / 2;
        -: 1561:
    #####: 1562:    m_state.scanDialogVisible = true;
        -: 1563:    
        -: 1564:    // Dimmed overlay
    #####: 1565:    drawRect(0, 0, m_width, m_height, 0x80000000);
        -: 1566:    
        -: 1567:    // Dialog box
    #####: 1568:    drawRect(boxX, boxY, boxW, boxH, m_theme.surface);
    #####: 1569:    drawRect(boxX, boxY, boxW, boxH, m_theme.border, false);
        -: 1570:    
        -: 1571:    // Title
    #####: 1572:    drawText("Scanning Media Files", boxX + 20, boxY + 15, m_theme.textPrimary, 18);
        -: 1573:    
        -: 1574:    // Path
    #####: 1575:    std::string shortPath = path;
    #####: 1576:    if (shortPath.length() > 45) {
    #####: 1577:        shortPath = "..." + shortPath.substr(shortPath.length() - 42);
        -: 1578:    }
    #####: 1579:    drawText(shortPath, boxX + 20, boxY + 50, m_theme.textDim, 12);
        -: 1580:    
        -: 1581:    // Progress bar
    #####: 1582:    float progress = total > 0 ? static_cast<float>(current) / total : 0;
    #####: 1583:    drawProgressBar(boxX + 20, boxY + 80, boxW - 40, 12, progress, 
        -: 1584:                    m_theme.primary, m_theme.scrollbar);
        -: 1585:    
        -: 1586:    // Count
    #####: 1587:    std::string countText = std::to_string(current) + " files found";
    #####: 1588:    drawText(countText, boxX + 20, boxY + 105, m_theme.textSecondary, 12);
        -: 1589:    
        -: 1590:    // Cancel button
    #####: 1591:    int cancelBtnW = 100;
    #####: 1592:    int cancelBtnH = 30;
    #####: 1593:    int cancelBtnX = boxX + (boxW - cancelBtnW) / 2;
    #####: 1594:    int cancelBtnY = boxY + 130;
        -: 1595:    
    #####: 1596:    bool cancelHover = isMouseOver(cancelBtnX, cancelBtnY, cancelBtnW, cancelBtnH);
    #####: 1597:    drawRect(cancelBtnX, cancelBtnY, cancelBtnW, cancelBtnH, 
        -: 1598:             cancelHover ? m_theme.error : m_theme.surfaceHover);
    #####: 1599:    drawText("Cancel", cancelBtnX + 28, cancelBtnY + 7, m_theme.textPrimary, 14);
        -: 1600:    
    #####: 1601:    if (cancelHover && m_modalMouseClicked && m_onCancelScan)
        -: 1602:    {
    #####: 1603:        m_onCancelScan();
    #####: 1604:        m_modalMouseClicked = false;
        -: 1605:    }
    #####: 1606:}
        -: 1607:
    #####: 1608:void ImGuiManager::showUsbPopup(const std::string& path) {
    #####: 1609:    m_state.showUsbDialog = true;
    #####: 1610:    m_state.usbPath = path;
    #####: 1611:}
        -: 1612:
    #####: 1613:void ImGuiManager::renderPathInputScreen(const std::string& currentPathPlaceholder) {
    #####: 1614:    int boxW = 520;
    #####: 1615:    int boxH = 180;
    #####: 1616:    int boxX = (m_width - boxW) / 2;
    #####: 1617:    int boxY = (m_height - boxH) / 2;
        -: 1618:    
    #####: 1619:    drawRect(0, 0, m_width, m_height, 0x80000000);
    #####: 1620:    drawRect(boxX, boxY, boxW, boxH, m_theme.surface);
    #####: 1621:    drawRect(boxX, boxY, boxW, boxH, m_theme.border, false);
        -: 1622:    
    #####: 1623:    drawText("Chọn thư mục thư viện", boxX + 20, boxY + 15, m_theme.textPrimary, 18);
        -: 1624:    
    #####: 1625:    int inputY = boxY + 50;
    #####: 1626:    int inputH = 32;
    #####: 1627:    drawRect(boxX + 20, inputY, boxW - 40, inputH, m_theme.background);
    #####: 1628:    drawRect(boxX + 20, inputY, boxW - 40, inputH, m_theme.border, false);
        -: 1629:    
    #####: 1630:    std::string displayText = m_state.libraryPathInput.empty() ? currentPathPlaceholder : m_state.libraryPathInput;
    #####: 1631:    if (displayText.length() > 58) displayText = "..." + displayText.substr(displayText.length() - 55);
    #####: 1632:    uint32_t textColor = m_state.libraryPathInput.empty() ? m_theme.textDim : m_theme.textPrimary;
    #####: 1633:    drawText(displayText, boxX + 28, inputY + 8, textColor, 14);
        -: 1634:    
    #####: 1635:    bool inputHover = isMouseOver(boxX + 20, inputY, boxW - 40, inputH);
    #####: 1636:    if (inputHover && m_mouseClicked) {
    #####: 1637:        m_state.focusPathInput = true;
    #####: 1638:        SDL_StartTextInput();
    #####: 1639:        m_mouseClicked = false;
        -: 1640:    }
    #####: 1641:    if (!inputHover && m_mouseClicked) {
    #####: 1642:        m_state.focusPathInput = false;
    #####: 1643:        SDL_StopTextInput();
        -: 1644:    }
        -: 1645:    
    #####: 1646:    int btnY = boxY + 100;
    #####: 1647:    int btnW = 120;
    #####: 1648:    int btnH = 36;
    #####: 1649:    bool scanHover = isMouseOver(boxX + boxW - 20 - btnW, btnY, btnW, btnH);
    #####: 1650:    drawRect(boxX + boxW - 20 - btnW, btnY, btnW, btnH, scanHover ? m_theme.primaryHover : m_theme.primary);
    #####: 1651:    drawText("Quét", boxX + boxW - 20 - btnW + 42, btnY + 10, m_theme.textPrimary, 14);
    #####: 1652:    if (scanHover && m_mouseClicked && m_onRequestScan) {
    #####: 1653:        m_onRequestScan(m_state.libraryPathInput.empty() ? currentPathPlaceholder : m_state.libraryPathInput);
    #####: 1654:        m_mouseClicked = false;
        -: 1655:    }
        -: 1656:    
    #####: 1657:    if (!m_state.libraryPathError.empty()) {
    #####: 1658:        std::string err = m_state.libraryPathError;
    #####: 1659:        if (err.length() > 60) err = err.substr(0, 57) + "...";
    #####: 1660:        drawText(err, boxX + 20, boxY + 148, m_theme.error, 12);
    #####: 1661:    }
    #####: 1662:}
        -: 1663:
    #####: 1664:void ImGuiManager::setControllers(
        -: 1665:    std::shared_ptr<controllers::PlaybackController> playback,
        -: 1666:    std::shared_ptr<controllers::QueueController> queue,
        -: 1667:    std::shared_ptr<controllers::LibraryController> library,
        -: 1668:    std::shared_ptr<controllers::PlaylistController> playlist
        -: 1669:) {
    #####: 1670:    m_playbackController = std::move(playback);
    #####: 1671:    m_queueController = std::move(queue);
    #####: 1672:    m_libraryController = std::move(library);
    #####: 1673:    m_playlistController = std::move(playlist);
    #####: 1674:}
        -: 1675:
    #####: 1676:void ImGuiManager::setMediaList(const std::vector<models::MediaFileModel>* mediaList) {
    #####: 1677:    m_mediaList = mediaList;
    #####: 1678:}
        -: 1679:
    #####: 1680:void ImGuiManager::setHistoryList(const std::vector<repositories::PlaybackHistoryEntry>& historyList) {
    #####: 1681:    m_historyList = historyList;
    #####: 1682:}
        -: 1683:
        -: 1684:// Drawing helpers
        -: 1685:
    #####: 1686:void ImGuiManager::drawRect(int x, int y, int w, int h, uint32_t color, bool filled) {
        -: 1687:    Uint8 r, g, b, a;
    #####: 1688:    unpackColor(color, r, g, b, a);
    #####: 1689:    SDL_SetRenderDrawColor(m_renderer, r, g, b, a);
        -: 1690:    
    #####: 1691:    SDL_Rect rect = {x, y, w, h};
    #####: 1692:    if (filled) {
    #####: 1693:        SDL_RenderFillRect(m_renderer, &rect);
        -: 1694:    } else {
    #####: 1695:        SDL_RenderDrawRect(m_renderer, &rect);
        -: 1696:    }
    #####: 1697:}
        -: 1698:
    #####: 1699:void ImGuiManager::drawRoundedRect(int x, int y, int w, int h, int radius, uint32_t color, bool filled) {
        -: 1700:    // Simplified - just draw normal rect
    #####: 1701:    drawRect(x, y, w, h, color, filled);
    #####: 1702:}
        -: 1703:
    #####: 1704:void ImGuiManager::drawText(const std::string& text, int x, int y, uint32_t color, int fontSize) {
    #####: 1705:    if (!m_font || text.empty()) return;
        -: 1706:    
    #####: 1707:    TTF_Font* font = m_font;
    #####: 1708:    if (fontSize >= 18 && m_fontLarge) {
    #####: 1709:        font = m_fontLarge;
    #####: 1710:    } else if (fontSize <= 12 && m_fontSmall) {
    #####: 1711:        font = m_fontSmall;
        -: 1712:    }
        -: 1713:    
        -: 1714:    Uint8 r, g, b, a;
    #####: 1715:    unpackColor(color, r, g, b, a);
    #####: 1716:    SDL_Color sdlColor = {r, g, b, a};
        -: 1717:    
    #####: 1718:    SDL_Surface* surface = TTF_RenderUTF8_Blended(font, text.c_str(), sdlColor);
    #####: 1719:    if (!surface) return;
        -: 1720:    
    #####: 1721:    SDL_Texture* texture = SDL_CreateTextureFromSurface(m_renderer, surface);
    #####: 1722:    if (texture) {
    #####: 1723:        SDL_Rect destRect = {x, y, surface->w, surface->h};
    #####: 1724:        SDL_RenderCopy(m_renderer, texture, nullptr, &destRect);
    #####: 1725:        SDL_DestroyTexture(texture);
        -: 1726:    }
        -: 1727:    
    #####: 1728:    SDL_FreeSurface(surface);
        -: 1729:}
        -: 1730:
    #####: 1731:void ImGuiManager::drawIcon(const std::string& icon, int x, int y, uint32_t color, int size) {
    #####: 1732:    drawText(icon, x, y, color, size);
    #####: 1733:}
        -: 1734:
    #####: 1735:void ImGuiManager::drawProgressBar(int x, int y, int w, int h, float progress, uint32_t fg, uint32_t bg) {
        -: 1736:    // Background
    #####: 1737:    drawRect(x, y, w, h, bg);
        -: 1738:    
        -: 1739:    // Progress
    #####: 1740:    int progressW = static_cast<int>(w * std::clamp(progress, 0.0f, 1.0f));
    #####: 1741:    if (progressW > 0) {
    #####: 1742:        drawRect(x, y, progressW, h, fg);
        -: 1743:    }
    #####: 1744:}
        -: 1745:
    #####: 1746:void ImGuiManager::drawButton(const std::string& label, int x, int y, int w, int h, bool active) {
    #####: 1747:    bool hover = isMouseOver(x, y, w, h);
    #####: 1748:    uint32_t bg = active ? m_theme.primary : (hover ? m_theme.surfaceHover : m_theme.surface);
        -: 1749:    
    #####: 1750:    drawRect(x, y, w, h, bg);
    #####: 1751:    drawRect(x, y, w, h, m_theme.border, false);
        -: 1752:    
        -: 1753:    // Center text
    #####: 1754:    int textX = x + 10;
    #####: 1755:    int textY = y + (h - 14) / 2;
    #####: 1756:    drawText(label, textX, textY, m_theme.textPrimary, 14);
    #####: 1757:}
        -: 1758:
    #####: 1759:void ImGuiManager::drawSlider(float* value, int x, int y, int w, int h) {
    #####: 1760:    drawRect(x, y + h/2 - 2, w, 4, m_theme.scrollbar);
        -: 1761:    
    #####: 1762:    int knobX = x + static_cast<int>(w * (*value)) - 4;
    #####: 1763:    drawRect(knobX, y, 8, h, m_theme.primary);
        -: 1764:    
    #####: 1765:    if (isMouseOver(x, y, w, h) && m_mouseDown) {
    #####: 1766:        *value = std::clamp(static_cast<float>(m_mouseX - x) / w, 0.0f, 1.0f);
        -: 1767:    }
    #####: 1768:}
        -: 1769:
    #####: 1770:void ImGuiManager::renderOverlays() {
        -: 1771:    // 0a. USB Connected Dialog (High Priority)
    #####: 1772:    if (m_state.showUsbDialog) {
    #####: 1773:        int boxW = 400;
    #####: 1774:        int boxH = 160;
    #####: 1775:        int boxX = (m_width - boxW) / 2;
    #####: 1776:        int boxY = (m_height - boxH) / 2;
        -: 1777:        
    #####: 1778:        drawRect(0, 0, m_width, m_height, 0x80000000); // Dim background
    #####: 1779:        drawRect(boxX, boxY, boxW, boxH, m_theme.surface);
    #####: 1780:        drawRect(boxX, boxY, boxW, boxH, m_theme.border, false);
        -: 1781:        
    #####: 1782:        drawText("USB Connected", boxX + 20, boxY + 20, m_theme.textPrimary, 18);
        -: 1783:        
    #####: 1784:        std::string msg = "Detected USB drive at:";
    #####: 1785:        drawText(msg, boxX + 20, boxY + 50, m_theme.textSecondary, 14);
        -: 1786:        
    #####: 1787:        std::string pathDisp = m_state.usbPath;
    #####: 1788:        if (pathDisp.length() > 45) pathDisp = "..." + pathDisp.substr(pathDisp.length() - 42);
    #####: 1789:        drawText(pathDisp, boxX + 20, boxY + 70, m_theme.primary, 14);
        -: 1790:        
        -: 1791:        // Buttons
    #####: 1792:        int btnY = boxY + 110;
        -: 1793:        
        -: 1794:        // Change Source Button
    #####: 1795:        int changeW = 140;
    #####: 1796:        int changeH = 35;
    #####: 1797:        int changeX = boxX + boxW - 20 - changeW;
    #####: 1798:        bool changeHover = isMouseOver(changeX, btnY, changeW, changeH);
    #####: 1799:        drawRect(changeX, btnY, changeW, changeH, changeHover ? m_theme.primaryHover : m_theme.primary);
    #####: 1800:        drawText("Change Source", changeX + 15, btnY + 9, m_theme.textPrimary, 14);
        -: 1801:        
    #####: 1802:        if (changeHover && m_modalMouseClicked) { // Use modal click flag
    #####: 1803:            if (m_onRequestScan) {
    #####: 1804:                m_onRequestScan(m_state.usbPath);
        -: 1805:            }
    #####: 1806:            m_state.showUsbDialog = false;
    #####: 1807:            m_modalMouseClicked = false;
        -: 1808:        }
        -: 1809:        
        -: 1810:        // Close (X) Button - top right
    #####: 1811:        int closeSize = 30;
    #####: 1812:        int closeX = boxX + boxW - 30;
    #####: 1813:        int closeY = boxY;
    #####: 1814:        bool closeHover = isMouseOver(closeX, closeY, closeSize, closeSize);
    #####: 1815:        if (closeHover) drawRect(closeX, closeY, closeSize, closeSize, m_theme.error);
    #####: 1816:        drawText("X", closeX + 10, closeY + 5, m_theme.textPrimary, 14);
        -: 1817:        
    #####: 1818:        if (closeHover && m_modalMouseClicked) { // Use modal click flag
    #####: 1819:             m_state.showUsbDialog = false;
    #####: 1820:             m_modalMouseClicked = false;
        -: 1821:        }
    #####: 1822:    }
        -: 1823:
        -: 1824:    // 0. Change library path dialog (Settings)
    #####: 1825:    if (m_state.showChangePathDialog) {
    #####: 1826:        int boxW = 520;
    #####: 1827:        int boxH = 200;
    #####: 1828:        int boxX = (m_width - boxW) / 2;
    #####: 1829:        int boxY = (m_height - boxH) / 2;
    #####: 1830:        drawRect(0, 0, m_width, m_height, 0x80000000);
        -: 1831:        // Close modal when clicking outside the dialog area
    #####: 1832:        bool clickOutside = m_modalMouseClicked && !isMouseOver(boxX, boxY, boxW, boxH);
    #####: 1833:        if (clickOutside)
        -: 1834:        {
    #####: 1835:            m_state.showChangePathDialog = false;
    #####: 1836:            m_state.focusPathInput = false;
    #####: 1837:            SDL_StopTextInput();
    #####: 1838:            m_modalMouseClicked = false;
    #####: 1839:            return;
        -: 1840:        }
    #####: 1841:        drawRect(boxX, boxY, boxW, boxH, m_theme.surface);
    #####: 1842:        drawRect(boxX, boxY, boxW, boxH, m_theme.border, false);
    #####: 1843:        drawText("Đổi thư mục thư viện", boxX + 20, boxY + 15, m_theme.textPrimary, 18);
    #####: 1844:        int inputY = boxY + 50;
    #####: 1845:        int inputH = 32;
    #####: 1846:        drawRect(boxX + 20, inputY, boxW - 40, inputH, m_theme.background);
    #####: 1847:        drawRect(boxX + 20, inputY, boxW - 40, inputH, m_theme.border, false);
    #####: 1848:        std::string disp = m_state.libraryPathInput.empty() ? "(đường dẫn)" : m_state.libraryPathInput;
    #####: 1849:        if (disp.length() > 58) disp = "..." + disp.substr(disp.length() - 55);
    #####: 1850:        drawText(disp, boxX + 28, inputY + 8, m_state.libraryPathInput.empty() ? m_theme.textDim : m_theme.textPrimary, 14);
    #####: 1851:        bool inputHover = isMouseOver(boxX + 20, inputY, boxW - 40, inputH);
    #####: 1852:        if (inputHover && m_modalMouseClicked)
        -: 1853:        {
    #####: 1854:            m_state.focusPathInput = true;
    #####: 1855:            SDL_StartTextInput();
    #####: 1856:            m_modalMouseClicked = false;
        -: 1857:        }
    #####: 1858:        int btnY = boxY + 100;
    #####: 1859:        int apW = 100, huW = 80, btnH = 36;
    #####: 1860:        bool apHover = isMouseOver(boxX + boxW - 20 - apW - 10 - huW, btnY, apW, btnH);
    #####: 1861:        bool huHover = isMouseOver(boxX + boxW - 20 - huW, btnY, huW, btnH);
    #####: 1862:        drawRect(boxX + boxW - 20 - apW - 10 - huW, btnY, apW, btnH, apHover ? m_theme.primaryHover : m_theme.primary);
    #####: 1863:        drawText("Scan", boxX + boxW - 20 - apW - 10 - huW + 28, btnY + 10, m_theme.textPrimary, 14);
    #####: 1864:        drawRect(boxX + boxW - 20 - huW, btnY, huW, btnH, huHover ? m_theme.surfaceHover : m_theme.surfaceActive);
    #####: 1865:        drawText("Cancel", boxX + boxW - 20 - huW + 22, btnY + 10, m_theme.textPrimary, 14);
    #####: 1866:        if (apHover && m_modalMouseClicked && m_onChangeLibraryPath)
        -: 1867:        {
    #####: 1868:            m_onChangeLibraryPath(m_state.libraryPathInput.empty() ? "" : m_state.libraryPathInput);
    #####: 1869:            m_modalMouseClicked = false;
        -: 1870:        }
    #####: 1871:        if (huHover && m_modalMouseClicked)
        -: 1872:        {
    #####: 1873:            m_state.showChangePathDialog = false;
    #####: 1874:            m_state.focusPathInput = false;
    #####: 1875:            SDL_StopTextInput();
    #####: 1876:            m_modalMouseClicked = false;
        -: 1877:        }
    #####: 1878:        if (!m_state.libraryPathError.empty()) {
    #####: 1879:            std::string err = m_state.libraryPathError;
    #####: 1880:            if (err.length() > 60) err = err.substr(0, 57) + "...";
    #####: 1881:            drawText(err, boxX + 20, boxY + 168, m_theme.error, 12);
    #####: 1882:        }
    #####: 1883:    }
        -: 1884:    
        -: 1885:    // 1. Context Menu
    #####: 1886:    if (m_state.showContextMenu) {
    #####: 1887:        int menuW = 150;
    #####: 1888:        int menuH = 140; // 4 items (35 each)
        -: 1889:        
        -: 1890:        // Draw Menu Background
    #####: 1891:        drawRect(m_state.contextMenuX, m_state.contextMenuY, menuW, menuH, m_theme.surfaceHover);
    #####: 1892:        drawRect(m_state.contextMenuX, m_state.contextMenuY, menuW, menuH, m_theme.border, false); // Border
        -: 1893:        
        -: 1894:        // For unsupported files, only show Properties
    #####: 1895:        bool isSupported = !m_state.contextMediaItem.isUnsupported();
        -: 1896:
        -: 1897:        // Item 1: Add to Playlist
    #####: 1898:        int y = m_state.contextMenuY;
    #####: 1899:        if (isSupported) {
    #####: 1900:            if (isMouseOver(m_state.contextMenuX, y, menuW, 35)) {
    #####: 1901:                drawRect(m_state.contextMenuX, y, menuW, 35, m_theme.primary);
    #####: 1902:                if (m_mouseClicked) {
    #####: 1903:                    m_state.showContextMenu = false;
    #####: 1904:                    m_state.showAddToPlaylistDialog = true;
    #####: 1905:                    m_mouseClicked = false;
        -: 1906:                }
        -: 1907:            }
    #####: 1908:            drawText("Add to Playlist", m_state.contextMenuX + 10, y + 8, m_theme.textPrimary, 14);
    #####: 1909:            y += 35;
        -: 1910:        }
        -: 1911:
        -: 1912:        // Item 2: Add to Queue
    #####: 1913:        if (isSupported) {
    #####: 1914:            if (isMouseOver(m_state.contextMenuX, y, menuW, 35)) {
    #####: 1915:                drawRect(m_state.contextMenuX, y, menuW, 35, m_theme.primary);
    #####: 1916:                if (m_mouseClicked) {
    #####: 1917:                     if (m_queueController) {
    #####: 1918:                        m_queueController->addToQueue(m_state.contextMediaItem);
        -: 1919:                     }
    #####: 1920:                    m_state.showContextMenu = false;
    #####: 1921:                    m_mouseClicked = false;
        -: 1922:                }
        -: 1923:            }
    #####: 1924:            drawText("Add to Queue", m_state.contextMenuX + 10, y + 8, m_theme.textPrimary, 14);
    #####: 1925:            y += 35;
        -: 1926:        }
        -: 1927:        
        -: 1928:        // Item 3: Play Next
    #####: 1929:        if (isSupported) {
    #####: 1930:            if (isMouseOver(m_state.contextMenuX, y, menuW, 35)) {
    #####: 1931:                drawRect(m_state.contextMenuX, y, menuW, 35, m_theme.primary);
    #####: 1932:                if (m_mouseClicked) {
    #####: 1933:                     if (m_queueController) {
    #####: 1934:                        m_queueController->addToQueueNext(m_state.contextMediaItem);
        -: 1935:                     }
    #####: 1936:                    m_state.showContextMenu = false;
    #####: 1937:                    m_mouseClicked = false;
        -: 1938:                }
        -: 1939:            }
    #####: 1940:            drawText("Play Next", m_state.contextMenuX + 10, y + 8, m_theme.textPrimary, 14);
    #####: 1941:            y += 35;
        -: 1942:        }
        -: 1943:        
        -: 1944:        // Item 4: Properties
    #####: 1945:        if (isMouseOver(m_state.contextMenuX, y, menuW, 35)) {
    #####: 1946:            drawRect(m_state.contextMenuX, y, menuW, 35, m_theme.primary);
    #####: 1947:            if (m_mouseClicked) {
    #####: 1948:                m_state.showContextMenu = false;
    #####: 1949:                m_state.showPropertiesDialog = true;
    #####: 1950:                const auto& media = m_state.contextMediaItem;
    #####: 1951:                m_state.metadataEdit.filePath = media.getFilePath();
    #####: 1952:                m_state.metadataEdit.fileName = media.getFileName();
    #####: 1953:                m_state.metadataEdit.extension = media.getExtension();
    #####: 1954:                m_state.metadataEdit.typeStr = media.isAudio() ? "Audio" : (media.isVideo() ? "Video" : (media.isUnsupported() ? "Unsupported" : "Unknown"));
    #####: 1955:                size_t sz = media.getFileSize();
    #####: 1956:                if (sz >= 1024 * 1024)
    #####: 1957:                    m_state.metadataEdit.fileSizeStr = std::to_string(sz / (1024 * 1024)) + " MB";
    #####: 1958:                else if (sz >= 1024)
    #####: 1959:                    m_state.metadataEdit.fileSizeStr = std::to_string(sz / 1024) + " KB";
        -: 1960:                else
    #####: 1961:                    m_state.metadataEdit.fileSizeStr = std::to_string(sz) + " B";
    #####: 1962:                int dur = media.getDuration();
    #####: 1963:                m_state.metadataEdit.durationStr = (dur > 0) ? (std::to_string(dur / 60) + ":" + (dur % 60 < 10 ? "0" : "") + std::to_string(dur % 60)) : "-";
    #####: 1964:                m_state.metadataEdit.title = media.getTitle().empty() ? media.getFileName() : media.getTitle();
    #####: 1965:                m_state.metadataEdit.artist = media.getArtist().empty() ? "-" : media.getArtist();
    #####: 1966:                m_state.metadataEdit.album = media.getAlbum().empty() ? "-" : media.getAlbum();
    #####: 1967:                m_state.metadataEdit.genre = "-";
    #####: 1968:                m_state.metadataEdit.year = "-";
    #####: 1969:                m_state.metadataEdit.publisher = "-";
    #####: 1970:                m_state.metadataEdit.bitrateStr = "-";
    #####: 1971:                if (m_getMetadataForProperties && !media.isUnsupported()) {
    #####: 1972:                    auto meta = m_getMetadataForProperties(media.getFilePath());
    #####: 1973:                    if (meta) {
    #####: 1974:                        if (!meta->getTitle().empty()) m_state.metadataEdit.title = meta->getTitle();
    #####: 1975:                        if (!meta->getArtist().empty()) m_state.metadataEdit.artist = meta->getArtist();
    #####: 1976:                        if (!meta->getAlbum().empty()) m_state.metadataEdit.album = meta->getAlbum();
    #####: 1977:                        if (!meta->getGenre().empty()) m_state.metadataEdit.genre = meta->getGenre();
    #####: 1978:                        if (!meta->getYear().empty()) m_state.metadataEdit.year = meta->getYear();
    #####: 1979:                        if (!meta->getPublisher().empty()) m_state.metadataEdit.publisher = meta->getPublisher();
    #####: 1980:                        m_state.metadataEdit.durationStr = meta->getFormattedDuration();
    #####: 1981:                        if (meta->getDuration() <= 0 && dur > 0)
    #####: 1982:                            m_state.metadataEdit.durationStr = std::to_string(dur / 60) + ":" + (dur % 60 < 10 ? "0" : "") + std::to_string(dur % 60);
    #####: 1983:                        if (meta->getBitrate() > 0) m_state.metadataEdit.bitrateStr = std::to_string(meta->getBitrate()) + " kbps";
        -: 1984:                    }
    #####: 1985:                }
    #####: 1986:                m_mouseClicked = false;
        -: 1987:            }
        -: 1988:        }
    #####: 1989:        drawText("Properties", m_state.contextMenuX + 10, y + 8, m_theme.textPrimary, 14);
        -: 1990:        
        -: 1991:        // Close if clicked outside
    #####: 1992:        if (m_mouseClicked && !isMouseOver(m_state.contextMenuX, m_state.contextMenuY, menuW, menuH)) {
    #####: 1993:            m_state.showContextMenu = false;
        -: 1994:        }
        -: 1995:    }
        -: 1996:    
        -: 1997:    // 2. Add to Playlist Dialog
    #####: 1998:    if (m_state.showAddToPlaylistDialog) {
    #####: 1999:        int dlgW = 400;
    #####: 2000:        int dlgH = 300;
    #####: 2001:        int x = (m_width - dlgW) / 2;
    #####: 2002:        int y = (m_height - dlgH) / 2;
        -: 2003:        
    #####: 2004:        drawRect(x, y, dlgW, dlgH, m_theme.surface);
    #####: 2005:        drawRect(x, y, dlgW, dlgH, m_theme.border, false); // Border
        -: 2006:        
    #####: 2007:        drawText("Add to Playlist", x + 20, y + 20, m_theme.textPrimary, 18);
    #####: 2008:        drawText("Select a playlist:", x + 20, y + 50, m_theme.textSecondary, 14);
        -: 2009:        
        -: 2010:        // List Playlists
    #####: 2011:        if (m_playlistController) {
    #####: 2012:            auto playlists = m_playlistController->getAllPlaylists();
    #####: 2013:            int listY = y + 80;
    #####: 2014:            for (const auto& pl : playlists) {
    #####: 2015:                if (listY > y + dlgH - 60) break;
        -: 2016:                
    #####: 2017:                if (isMouseOver(x + 20, listY, dlgW - 40, 30)) {
    #####: 2018:                    drawRect(x + 20, listY, dlgW - 40, 30, m_theme.surfaceHover);
    #####: 2019:                    if (m_mouseClicked) {
        -: 2020:                        // Add to this playlist
    #####: 2021:                         m_playlistController->addMediaToPlaylist(pl.getId(), m_state.contextMediaItem);
    #####: 2022:                        m_state.showAddToPlaylistDialog = false;
    #####: 2023:                        m_mouseClicked = false;
        -: 2024:                    }
        -: 2025:                }
    #####: 2026:                drawText(pl.getName(), x + 30, listY + 6, m_theme.textPrimary, 14);
    #####: 2027:                listY += 35;
        -: 2028:            }
    #####: 2029:        }
        -: 2030:        
        -: 2031:        // Cancel Button
    #####: 2032:        if (isMouseOver(x + dlgW - 100, y + dlgH - 40, 80, 30)) {
    #####: 2033:             drawRect(x + dlgW - 100, y + dlgH - 40, 80, 30, m_theme.surfaceActive);
    #####: 2034:             if (m_mouseClicked) {
    #####: 2035:                 m_state.showAddToPlaylistDialog = false;
    #####: 2036:                 m_mouseClicked = false;
        -: 2037:             }
        -: 2038:        } else {
    #####: 2039:             drawRect(x + dlgW - 100, y + dlgH - 40, 80, 30, m_theme.surfaceHover);
        -: 2040:        }
    #####: 2041:        drawText("Cancel", x + dlgW - 85, y + dlgH - 33, m_theme.textPrimary, 14);
        -: 2042:    }
        -: 2043:    
        -: 2044:    // 3. Properties Dialog (read-only, all metadata fields)
    #####: 2045:    if (m_state.showPropertiesDialog) {
    #####: 2046:        int dlgW = 420;
    #####: 2047:        int dlgH = 520;
    #####: 2048:        int x = (m_width - dlgW) / 2;
    #####: 2049:        int y = (m_height - dlgH) / 2;
        -: 2050:        
    #####: 2051:        drawRect(x, y, dlgW, dlgH, m_theme.surface);
    #####: 2052:        drawRect(x, y, dlgW, dlgH, m_theme.border, false);
        -: 2053:        
    #####: 2054:        drawText("Properties", x + 20, y + 16, m_theme.textPrimary, 18);
        -: 2055:        
    #####: 2056:        int labelX = x + 20;
    #####: 2057:        int valueX = x + 110;
    #####: 2058:        int fieldY = y + 48;
    #####: 2059:        const int rowH = 24;
        -: 2060:        
    #####: 2061:        auto drawRow = [&](const std::string& label, const std::string& value) {
    #####: 2062:            drawText(label + ":", labelX, fieldY, m_theme.textSecondary, 12);
    #####: 2063:            std::string v = value.empty() ? "-" : value;
    #####: 2064:            if (v.length() > 52) v = v.substr(0, 49) + "...";
    #####: 2065:            drawText(v, valueX, fieldY, m_theme.textPrimary, 12);
    #####: 2066:            fieldY += rowH;
    #####: 2067:        };
        -: 2068:        
    #####: 2069:        drawRow("Title", m_state.metadataEdit.title);
    #####: 2070:        drawRow("Artist", m_state.metadataEdit.artist);
    #####: 2071:        drawRow("Album", m_state.metadataEdit.album);
    #####: 2072:        drawRow("Genre", m_state.metadataEdit.genre);
    #####: 2073:        drawRow("Year", m_state.metadataEdit.year);
    #####: 2074:        drawRow("Publisher", m_state.metadataEdit.publisher);
    #####: 2075:        drawRow("Duration", m_state.metadataEdit.durationStr);
    #####: 2076:        drawRow("Bitrate", m_state.metadataEdit.bitrateStr);
    #####: 2077:        drawRow("File name", m_state.metadataEdit.fileName);
    #####: 2078:        drawRow("Extension", m_state.metadataEdit.extension);
    #####: 2079:        drawRow("Type", m_state.metadataEdit.typeStr);
    #####: 2080:        drawRow("File size", m_state.metadataEdit.fileSizeStr);
    #####: 2081:        drawRow("File path", m_state.metadataEdit.filePath);
        -: 2082:
        -: 2083:        // Close Button
    #####: 2084:        int closeY = y + dlgH - 40;
    #####: 2085:        if (isMouseOver(x + dlgW - 100, closeY, 80, 30)) {
    #####: 2086:             drawRect(x + dlgW - 100, closeY, 80, 30, m_theme.surfaceActive);
    #####: 2087:             if (m_mouseClicked) {
    #####: 2088:                 m_state.showPropertiesDialog = false;
    #####: 2089:                 m_mouseClicked = false;
        -: 2090:             }
        -: 2091:        } else {
    #####: 2092:             drawRect(x + dlgW - 100, closeY, 80, 30, m_theme.surfaceHover);
        -: 2093:        }
    #####: 2094:        drawText("Close", x + dlgW - 85, closeY + 7, m_theme.textPrimary, 14);
        -: 2095:    }
        -: 2096:
        -: 2097:    // 4. Rename Playlist Dialog
    #####: 2098:    if (m_state.showRenamePlaylistDialog) {
    #####: 2099:        int dlgW = 400;
    #####: 2100:        int dlgH = 200;
    #####: 2101:        int x = (m_width - dlgW) / 2;
    #####: 2102:        int y = (m_height - dlgH) / 2;
        -: 2103:        
    #####: 2104:        drawRect(x, y, dlgW, dlgH, m_theme.surface);
    #####: 2105:        drawRect(x, y, dlgW, dlgH, m_theme.border, false); // Border
        -: 2106:        
    #####: 2107:        drawText("Rename Playlist", x + 20, y + 20, m_theme.textPrimary, 18);
        -: 2108:        
        -: 2109:        // Input Box
    #####: 2110:        drawRect(x + 20, y + 60, dlgW - 40, 30, m_theme.background);
    #####: 2111:        drawRect(x + 20, y + 60, dlgW - 40, 30, m_theme.primary, false);
        -: 2112:        
    #####: 2113:        std::string display = m_state.renamePlaylistName + "_";
    #####: 2114:        drawText(display, x + 30, y + 68, m_theme.textPrimary, 14);
        -: 2115:        
    #####: 2116:        drawText("Press Enter to save, Esc to cancel", x + 20, y + 100, m_theme.textDim, 12);
        -: 2117:        
        -: 2118:        // Save Button
    #####: 2119:        if (isMouseOver(x + dlgW - 180, y + dlgH - 40, 70, 30)) {
    #####: 2120:             drawRect(x + dlgW - 180, y + dlgH - 40, 70, 30, m_theme.primary);
    #####: 2121:             if (m_mouseClicked) {
    #####: 2122:                 if (!m_state.renamePlaylistName.empty() && m_playlistController) {
    #####: 2123:                     m_playlistController->renamePlaylist(m_state.renamePlaylistId, m_state.renamePlaylistName);
        -: 2124:                 }
    #####: 2125:                 m_state.showRenamePlaylistDialog = false;
    #####: 2126:                 SDL_StopTextInput();
    #####: 2127:                 m_mouseClicked = false;
        -: 2128:             }
        -: 2129:        }
    #####: 2130:        drawText("Save", x + dlgW - 160, y + dlgH - 33, m_theme.textPrimary, 14);
        -: 2131:        
        -: 2132:        // Cancel Button - always draw background
    #####: 2133:        bool cancelHover = isMouseOver(x + dlgW - 100, y + dlgH - 40, 70, 30);
    #####: 2134:        drawRect(x + dlgW - 100, y + dlgH - 40, 70, 30, cancelHover ? m_theme.surfaceActive : m_theme.surfaceHover);
    #####: 2135:        if (cancelHover && m_mouseClicked) {
    #####: 2136:            m_state.showRenamePlaylistDialog = false;
    #####: 2137:            m_state.renamePlaylistName.clear();
    #####: 2138:            SDL_StopTextInput();
    #####: 2139:            m_mouseClicked = false;
        -: 2140:        }
    #####: 2141:        drawText("Cancel", x + dlgW - 90, y + dlgH - 33, m_theme.textPrimary, 14);
    #####: 2142:    }
        -: 2143:}
        -: 2144:
    #####: 2145:bool ImGuiManager::isMouseOver(int x, int y, int w, int h) const {
    #####: 2146:    return m_mouseX >= x && m_mouseX < x + w && m_mouseY >= y && m_mouseY < y + h;
        -: 2147:}
        -: 2148:
    #####: 2149:bool ImGuiManager::isMouseClicked(int x, int y, int w, int h) const {
    #####: 2150:    return m_mouseClicked && isMouseOver(x, y, w, h);
        -: 2151:}
        -: 2152:
    #####: 2153:bool ImGuiManager::isMouseDragging() const {
    #####: 2154:    return m_mouseDown;
        -: 2155:}
        -: 2156:
        -: 2157:} // namespace ui
        -: 2158:} // namespace media_player
