        -:    0:Source:/home/duong/MediaPlayerApp/src/views/LibraryScreen.cpp
        -:    0:Graph:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/views/LibraryScreen.cpp.gcno
        -:    0:Data:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/views/LibraryScreen.cpp.gcda
        -:    0:Runs:6
        -:    1:// Project includes
        -:    2:#include "views/LibraryScreen.h"
        -:    3:#include "utils/Logger.h"
        -:    4:#include "config/AppConfig.h"
        -:    5:
        -:    6:namespace media_player 
        -:    7:{
        -:    8:namespace views 
        -:    9:{
        -:   10:
    #####:   11:LibraryScreen::LibraryScreen(
        -:   12:    std::shared_ptr<controllers::LibraryController> libraryController,
        -:   13:    std::shared_ptr<controllers::QueueController> queueController
    #####:   14:)
    #####:   15:    : m_libraryController(libraryController)
    #####:   16:    , m_queueController(queueController)
    #####:   17:    , m_currentPage(0)
    #####:   18:    , m_itemsPerPage(config::AppConfig::MAX_ITEMS_PER_PAGE)
    #####:   19:    , m_selectedIndex(-1)
    #####:   20:    , m_isVisible(false)
        -:   21:{
    #####:   22:    LOG_INFO("LibraryScreen created");
    #####:   23:}
        -:   24:
    #####:   25:LibraryScreen::~LibraryScreen() 
        -:   26:{
    #####:   27:    LOG_INFO("LibraryScreen destroyed");
    #####:   28:}
------------------
_ZN12media_player5views13LibraryScreenD0Ev:
    #####:   25:LibraryScreen::~LibraryScreen() 
        -:   26:{
        -:   27:    LOG_INFO("LibraryScreen destroyed");
    #####:   28:}
------------------
_ZN12media_player5views13LibraryScreenD2Ev:
    #####:   25:LibraryScreen::~LibraryScreen() 
        -:   26:{
    #####:   27:    LOG_INFO("LibraryScreen destroyed");
    #####:   28:}
------------------
        -:   29:
    #####:   30:void LibraryScreen::show() 
        -:   31:{
    #####:   32:    m_isVisible = true;
    #####:   33:    refreshMediaList();
    #####:   34:    LOG_INFO("LibraryScreen shown");
    #####:   35:}
        -:   36:
    #####:   37:void LibraryScreen::hide() 
        -:   38:{
    #####:   39:    m_isVisible = false;
    #####:   40:    LOG_INFO("LibraryScreen hidden");
    #####:   41:}
        -:   42:
    #####:   43:void LibraryScreen::update() 
        -:   44:{
    #####:   45:    if (!m_isVisible) 
        -:   46:    {
    #####:   47:        return;
        -:   48:    }
        -:   49:    
    #####:   50:    displayMediaList();
        -:   51:}
        -:   52:
    #####:   53:bool LibraryScreen::isVisible() const 
        -:   54:{
    #####:   55:    return m_isVisible;
        -:   56:}
        -:   57:
    #####:   58:void LibraryScreen::nextPage() 
        -:   59:{
    #####:   60:    size_t totalItems = m_currentMediaList.size();
    #####:   61:    size_t totalPages = (totalItems + m_itemsPerPage - 1) / m_itemsPerPage;
        -:   62:    
    #####:   63:    if (m_currentPage < totalPages - 1) 
        -:   64:    {
    #####:   65:        m_currentPage++;
    #####:   66:        update();
        -:   67:    }
    #####:   68:}
        -:   69:
    #####:   70:void LibraryScreen::previousPage() 
        -:   71:{
    #####:   72:    if (m_currentPage > 0) 
        -:   73:    {
    #####:   74:        m_currentPage--;
    #####:   75:        update();
        -:   76:    }
    #####:   77:}
        -:   78:
    #####:   79:void LibraryScreen::goToPage(size_t pageNumber) 
        -:   80:{
    #####:   81:    size_t totalItems = m_currentMediaList.size();
    #####:   82:    size_t totalPages = (totalItems + m_itemsPerPage - 1) / m_itemsPerPage;
        -:   83:    
    #####:   84:    if (pageNumber < totalPages) 
        -:   85:    {
    #####:   86:        m_currentPage = pageNumber;
    #####:   87:        update();
        -:   88:    }
    #####:   89:}
        -:   90:
    #####:   91:void LibraryScreen::showAllMedia() 
        -:   92:{
    #####:   93:    m_currentMediaList = m_libraryController->getAllMedia();
    #####:   94:    m_currentPage = 0;
    #####:   95:    update();
    #####:   96:}
        -:   97:
    #####:   98:void LibraryScreen::showAudioOnly() 
        -:   99:{
    #####:  100:    m_currentMediaList = m_libraryController->getAudioFiles();
    #####:  101:    m_currentPage = 0;
    #####:  102:    update();
    #####:  103:}
        -:  104:
    #####:  105:void LibraryScreen::showVideoOnly() 
        -:  106:{
    #####:  107:    m_currentMediaList = m_libraryController->getVideoFiles();
    #####:  108:    m_currentPage = 0;
    #####:  109:    update();
    #####:  110:}
        -:  111:
    #####:  112:void LibraryScreen::searchMedia(const std::string& query) 
        -:  113:{
    #####:  114:    m_currentMediaList = m_libraryController->search(query);
    #####:  115:    m_currentPage = 0;
    #####:  116:    update();
    #####:  117:}
        -:  118:
    #####:  119:void LibraryScreen::sortByTitle() 
        -:  120:{
    #####:  121:    m_currentMediaList = m_libraryController->sortByTitle();
    #####:  122:    update();
    #####:  123:}
        -:  124:
    #####:  125:void LibraryScreen::sortByArtist() 
        -:  126:{
    #####:  127:    m_currentMediaList = m_libraryController->sortByArtist();
    #####:  128:    update();
    #####:  129:}
        -:  130:
    #####:  131:void LibraryScreen::sortByAlbum() 
        -:  132:{
    #####:  133:    m_currentMediaList = m_libraryController->sortByAlbum();
    #####:  134:    update();
    #####:  135:}
        -:  136:
    #####:  137:void LibraryScreen::playSelected() 
        -:  138:{
    #####:  139:    if (m_selectedIndex < 0 || m_selectedIndex >= static_cast<int>(m_currentMediaList.size())) 
        -:  140:    {
    #####:  141:        return;
        -:  142:    }
        -:  143:    
    #####:  144:    m_queueController->clearQueue();
    #####:  145:    m_queueController->addToQueue(m_currentMediaList[m_selectedIndex]);
        -:  146:    
        -:  147:    // Trigger playback
    #####:  148:    LOG_INFO("Play selected: " + m_currentMediaList[m_selectedIndex].getFileName());
        -:  149:}
        -:  150:
    #####:  151:void LibraryScreen::addSelectedToQueue() 
        -:  152:{
    #####:  153:    if (m_selectedIndex < 0 || m_selectedIndex >= static_cast<int>(m_currentMediaList.size())) 
        -:  154:    {
    #####:  155:        return;
        -:  156:    }
        -:  157:    
    #####:  158:    m_queueController->addToQueue(m_currentMediaList[m_selectedIndex]);
    #####:  159:    LOG_INFO("Added to queue: " + m_currentMediaList[m_selectedIndex].getFileName());
        -:  160:}
        -:  161:
    #####:  162:void LibraryScreen::addAllToQueue() 
        -:  163:{
    #####:  164:    for (const auto& media : m_currentMediaList) 
        -:  165:    {
    #####:  166:        m_queueController->addToQueue(media);
        -:  167:    }
        -:  168:    
    #####:  169:    LOG_INFO("Added all media to queue");
    #####:  170:}
        -:  171:
    #####:  172:void LibraryScreen::refreshMediaList() 
        -:  173:{
    #####:  174:    m_currentMediaList = m_libraryController->getAllMedia();
    #####:  175:    m_currentPage = 0;
    #####:  176:}
        -:  177:
    #####:  178:void LibraryScreen::displayMediaList() 
        -:  179:{
    #####:  180:    size_t startIndex = m_currentPage * m_itemsPerPage;
    #####:  181:    size_t endIndex = std::min(startIndex + m_itemsPerPage, m_currentMediaList.size());
        -:  182:    
    #####:  183:    LOG_DEBUG("Displaying page " + std::to_string(m_currentPage + 1));
        -:  184:    
    #####:  185:    for (size_t i = startIndex; i < endIndex; ++i) 
        -:  186:    {
    #####:  187:        const auto& media = m_currentMediaList[i];
        -:  188:        
    #####:  189:        std::string typeStr = media.isAudio() ? "[AUDIO]" : "[VIDEO]";
    #####:  190:        LOG_DEBUG(std::to_string(i + 1) + ". " + typeStr + " " + media.getFileName());
    #####:  191:    }
    #####:  192:}
        -:  193:
        -:  194:} // namespace views
        -:  195:} // namespace media_player
