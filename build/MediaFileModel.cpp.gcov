        -:    0:Source:/home/duong/MediaPlayerApp/src/models/MediaFileModel.cpp
        -:    0:Graph:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/models/MediaFileModel.cpp.gcno
        -:    0:Data:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/models/MediaFileModel.cpp.gcda
        -:    0:Runs:6
        -:    1:// Project includes
        -:    2:#include "models/MediaFileModel.h"
        -:    3:#include "config/AppConfig.h"
        -:    4:#include "utils/Logger.h"
        -:    5:
        -:    6:// System includes
        -:    7:#include <filesystem>
        -:    8:#include <algorithm>
        -:    9:
        -:   10:namespace fs = std::filesystem;
        -:   11:
        -:   12:namespace media_player 
        -:   13:{
        -:   14:namespace models 
        -:   15:{
        -:   16:
        6:   17:MediaFileModel::MediaFileModel()
        6:   18:    : m_type(MediaType::UNKNOWN)
        6:   19:    , m_fileSize(0)
        -:   20:{
        6:   21:}
        -:   22:
       42:   23:MediaFileModel::MediaFileModel(const std::string& filePath)
       42:   24:    : m_filePath(filePath)
       42:   25:    , m_type(MediaType::UNKNOWN)
       42:   26:    , m_fileSize(0)
        -:   27:{
       42:   28:    extractFileInfo();
       42:   29:    m_type = determineMediaType();
       42:   30:}
        -:   31:
    #####:   32:bool MediaFileModel::isValid() const 
        -:   33:{
    #####:   34:    return !m_filePath.empty() && 
    #####:   35:           m_type != MediaType::UNKNOWN && 
    #####:   36:           fs::exists(m_filePath);
        -:   37:}
        -:   38:
    #####:   39:bool MediaFileModel::operator<(const MediaFileModel& other) const 
        -:   40:{
    #####:   41:    return m_fileName < other.m_fileName;
        -:   42:}
        -:   43:
    #####:   44:bool MediaFileModel::operator==(const MediaFileModel& other) const 
        -:   45:{
    #####:   46:    return m_filePath == other.m_filePath;
        -:   47:}
        -:   48:
    #####:   49:std::string MediaFileModel::serialize() const 
        -:   50:{
    #####:   51:    return m_filePath + "|" + 
    #####:   52:           m_fileName + "|" + 
    #####:   53:           m_extension + "|" + 
    #####:   54:           std::to_string(static_cast<int>(m_type)) + "|" + 
    #####:   55:           std::to_string(m_fileSize);
        -:   56:}
        -:   57:
    #####:   58:MediaFileModel MediaFileModel::deserialize(const std::string& data) 
        -:   59:{
        -:   60:    // Parse serialized string
    #####:   61:    size_t pos = 0;
    #####:   62:    size_t nextPos = data.find('|');
        -:   63:    
    #####:   64:    if (nextPos == std::string::npos) 
        -:   65:    {
    #####:   66:        return MediaFileModel();
        -:   67:    }
        -:   68:    
    #####:   69:    std::string filePath = data.substr(pos, nextPos - pos);
        -:   70:    
    #####:   71:    return MediaFileModel(filePath);
    #####:   72:}
        -:   73:
       42:   74:void MediaFileModel::extractFileInfo() 
        -:   75:{
       42:   76:    if (m_filePath.empty()) 
        -:   77:    {
    #####:   78:        return;
        -:   79:    }
        -:   80:    
        -:   81:    try 
        -:   82:    {
       42:   83:        fs::path path(m_filePath);
        -:   84:        
       42:   85:        m_fileName = path.filename().string();
       42:   86:        m_extension = path.extension().string();
        -:   87:        
        -:   88:        // Keep extension case-sensitive for specific checks (like .WAV vs .wav)
        -:   89:        // std::transform(m_extension.begin(), m_extension.end(), 
        -:   90:        //               m_extension.begin(), ::tolower);
        -:   91:        
       42:   92:        if (fs::exists(path)) 
        -:   93:        {
    #####:   94:            m_fileSize = fs::file_size(path);
    #####:   95:            m_lastModified = fs::last_write_time(path);
        -:   96:        }
       42:   97:    }
    =====:   98:    catch (const fs::filesystem_error& e) 
        -:   99:    {
    =====:  100:        LOG_ERROR("Error extracting file info: " + std::string(e.what()));
    =====:  101:    }
        -:  102:}
        -:  103:
       42:  104:MediaType MediaFileModel::determineMediaType() const 
        -:  105:{
        -:  106:    // Explicitly block all-uppercase extensions (e.g. .WAV, .MP3) as they might cause crashes
        -:  107:    // But allow .wav (supported)
        -:  108:    // We check if the extension has letters and ALL letters are uppercase
       42:  109:    bool hasLetters = false;
       42:  110:    bool allUpper = true;
        -:  111:    
      102:  112:    for (char c : m_extension) {
       96:  113:        if (std::isalpha(c)) {
       54:  114:            hasLetters = true;
       54:  115:            if (!std::isupper(c)) {
       36:  116:                allUpper = false;
       36:  117:                break;
        -:  118:            }
        -:  119:        }
        -:  120:    }
        -:  121:    
       42:  122:    if (hasLetters && allUpper)
        -:  123:    {
        6:  124:        return MediaType::UNSUPPORTED;
        -:  125:    }
        -:  126:
       36:  127:    std::string lowerExt = m_extension;
       36:  128:    std::transform(lowerExt.begin(), lowerExt.end(), lowerExt.begin(), ::tolower);
        -:  129:
        -:  130:    // Check against audio extensions
       36:  131:    const auto& audioExts = config::AppConfig::SUPPORTED_AUDIO_EXTENSIONS;
        -:  132:    
       36:  133:    if (std::find(audioExts.begin(), audioExts.end(), lowerExt) != audioExts.end()) 
        -:  134:    {
       30:  135:        return MediaType::AUDIO;
        -:  136:    }
        -:  137:    
        -:  138:    // Check against video extensions
        6:  139:    const auto& videoExts = config::AppConfig::SUPPORTED_VIDEO_EXTENSIONS;
        -:  140:    
        6:  141:    if (std::find(videoExts.begin(), videoExts.end(), lowerExt) != videoExts.end()) 
        -:  142:    {
        6:  143:        return MediaType::VIDEO;
        -:  144:    }
        -:  145:    
        -:  146:    // If we are here, it's likely a scannable but unsupported file (since FileScanner filters by SCANNABLE_EXTENSIONS)
        -:  147:    // But let's double check against SCANNABLE just to be safe, or just assume UNSUPPORTED
    #####:  148:    const auto& scannableExts = config::AppConfig::SCANNABLE_EXTENSIONS;
        -:  149:    
        -:  150:    // Use lowerExt for scannable check too
    #####:  151:    if (std::find(scannableExts.begin(), scannableExts.end(), lowerExt) != scannableExts.end())
        -:  152:    {
    #####:  153:        return MediaType::UNSUPPORTED;
        -:  154:    }
        -:  155:    
    #####:  156:    return MediaType::UNKNOWN;
       36:  157:}
        -:  158:
        -:  159:} // namespace models
        -:  160:} // namespace media_player
