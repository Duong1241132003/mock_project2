        -:    0:Source:/home/duong/MediaPlayerApp/src/services/FileScanner.cpp
        -:    0:Graph:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/services/FileScanner.cpp.gcno
        -:    0:Data:/home/duong/MediaPlayerApp/build/CMakeFiles/RunTests.dir/src/services/FileScanner.cpp.gcda
        -:    0:Runs:6
        -:    1:// Project includes
        -:    2:#include "services/FileScanner.h"
        -:    3:#include "config/AppConfig.h"
        -:    4:#include "utils/Logger.h"
        -:    5:
        -:    6:// TagLib includes
        -:    7:#include <taglib/fileref.h>
        -:    8:#include <taglib/tag.h>
        -:    9:#include <taglib/audioproperties.h>
        -:   10:
        -:   11:// System includes
        -:   12:#include <filesystem>
        -:   13:#include <algorithm>
        -:   14:
        -:   15:namespace fs = std::filesystem;
        -:   16:
        -:   17:namespace media_player 
        -:   18:{
        -:   19:namespace services 
        -:   20:{
        -:   21:
    #####:   22:FileScanner::FileScanner()
    #####:   23:    : m_maxDepth(config::AppConfig::MAX_SCAN_DEPTH)
    #####:   24:    , m_isScanning(false)
    #####:   25:    , m_shouldStop(false)
    #####:   26:    , m_scannedCount(0)
    #####:   27:    , m_totalFiles(0)
        -:   28:{
        -:   29:    // Initialize with audio and video extensions
        -:   30:    // Initialize with all scannable extensions
    #####:   31:    m_validExtensions = config::AppConfig::SCANNABLE_EXTENSIONS;
    #####:   32:}
        -:   33:
    #####:   34:FileScanner::~FileScanner() 
        -:   35:{
    #####:   36:    stopScanning();
    #####:   37:}
------------------
_ZN12media_player8services11FileScannerD0Ev:
    #####:   34:FileScanner::~FileScanner() 
        -:   35:{
        -:   36:    stopScanning();
    #####:   37:}
------------------
_ZN12media_player8services11FileScannerD2Ev:
    #####:   34:FileScanner::~FileScanner() 
        -:   35:{
    #####:   36:    stopScanning();
    #####:   37:}
------------------
        -:   38:
    #####:   39:void FileScanner::scanDirectory(const std::string& rootPath) 
        -:   40:{
    #####:   41:    if (m_isScanning) 
        -:   42:    {
    #####:   43:        LOG_WARNING("Scan already in progress. Ignoring new scan request.");
    #####:   44:        return;
        -:   45:    }
        -:   46:    
    #####:   47:    if (!fs::exists(rootPath)) 
        -:   48:    {
    #####:   49:        LOG_ERROR("Directory does not exist: " + rootPath);
    #####:   50:        return;
        -:   51:    }
        -:   52:    
    #####:   53:    if (!fs::is_directory(rootPath)) 
        -:   54:    {
    #####:   55:        LOG_ERROR("Path is not a directory: " + rootPath);
    #####:   56:        return;
        -:   57:    }
        -:   58:    
    #####:   59:    LOG_INFO("Starting scan of directory: " + rootPath);
        -:   60:    
    #####:   61:    m_shouldStop = false;
    #####:   62:    m_isScanning = true;
    #####:   63:    m_foundFiles.clear();
    #####:   64:    m_scannedCount = 0;
        -:   65:    
        -:   66:    // Start scanning in a separate thread
    #####:   67:    m_scanThread = std::make_unique<std::thread>(&FileScanner::scanWorker, this, rootPath);
        -:   68:}
        -:   69:
    #####:   70:void FileScanner::stopScanning() 
        -:   71:{
    #####:   72:    if (!m_isScanning) 
        -:   73:    {
    #####:   74:        return;
        -:   75:    }
        -:   76:    
    #####:   77:    LOG_INFO("Stopping scan...");
    #####:   78:    m_shouldStop = true;
        -:   79:    
    #####:   80:    if (m_scanThread && m_scanThread->joinable()) 
        -:   81:    {
    #####:   82:        m_scanThread->join();
        -:   83:    }
        -:   84:    
    #####:   85:    m_isScanning = false;
    #####:   86:    LOG_INFO("Scan stopped.");
        -:   87:}
        -:   88:
    #####:   89:bool FileScanner::isScanning() const 
        -:   90:{
    #####:   91:    return m_isScanning;
        -:   92:}
        -:   93:
    #####:   94:void FileScanner::setProgressCallback(ScanProgressCallback callback) 
        -:   95:{
    #####:   96:    m_progressCallback = callback;
    #####:   97:}
        -:   98:
    #####:   99:void FileScanner::setProgressCallback(ScanProgressCallback3 callback) 
        -:  100:{
    #####:  101:    m_progressCallback3 = callback;
    #####:  102:}
        -:  103:
    #####:  104:void FileScanner::setCompleteCallback(ScanCompleteCallback callback) 
        -:  105:{
    #####:  106:    m_completeCallback = callback;
    #####:  107:}
        -:  108:
        -:  109:// Synchronous scan that returns results directly
    #####:  110:std::vector<models::MediaFileModel> FileScanner::scanDirectorySync(const std::string& rootPath) 
        -:  111:{
    #####:  112:    if (!fs::exists(rootPath)) 
        -:  113:    {
    #####:  114:        LOG_ERROR("Directory does not exist: " + rootPath);
    #####:  115:        return {};
        -:  116:    }
        -:  117:    
    #####:  118:    if (!fs::is_directory(rootPath)) 
        -:  119:    {
    #####:  120:        LOG_ERROR("Path is not a directory: " + rootPath);
    #####:  121:        return {};
        -:  122:    }
        -:  123:    
    #####:  124:    LOG_INFO("Starting synchronous scan of: " + rootPath);
        -:  125:    
    #####:  126:    m_shouldStop = false;
    #####:  127:    m_isScanning = true;
    #####:  128:    m_foundFiles.clear();
    #####:  129:    m_scannedCount = 0;
        -:  130:    
        -:  131:    // Count total files first (estimate)
    #####:  132:    int totalEstimate = 0;
        -:  133:    try 
        -:  134:    {
    #####:  135:        for (auto& p : fs::recursive_directory_iterator(rootPath, fs::directory_options::skip_permission_denied)) 
        -:  136:        {
    #####:  137:            if (p.is_regular_file()) 
        -:  138:            {
    #####:  139:                std::string ext = p.path().extension().string();
    #####:  140:                std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
    #####:  141:                if (hasValidExtension(ext)) 
        -:  142:                {
    #####:  143:                    totalEstimate++;
        -:  144:                }
    #####:  145:            }
    #####:  146:        }
        -:  147:    }
    =====:  148:    catch (...) {}
        -:  149:    
    #####:  150:    m_totalFiles = totalEstimate;
        -:  151:    
    #####:  152:    scanRecursive(rootPath, 0);
        -:  153:    
    #####:  154:    m_isScanning = false;
    #####:  155:    LOG_INFO("Synchronous scan completed. Found " + std::to_string(m_foundFiles.size()) + " files");
        -:  156:    
    #####:  157:    return m_foundFiles;
        -:  158:}
        -:  159:
    #####:  160:void FileScanner::setMaxDepth(int depth) 
        -:  161:{
    #####:  162:    m_maxDepth = depth;
    #####:  163:}
        -:  164:
    #####:  165:void FileScanner::setFileExtensions(const std::vector<std::string>& extensions) 
        -:  166:{
    #####:  167:    m_validExtensions = extensions;
    #####:  168:}
        -:  169:
    #####:  170:void FileScanner::scanWorker(const std::string& rootPath) 
        -:  171:{
        -:  172:    try 
        -:  173:    {
    #####:  174:        scanRecursive(rootPath, 0);
        -:  175:        
    #####:  176:        if (!m_shouldStop) 
        -:  177:        {
    #####:  178:            LOG_INFO("Scan completed. Found " + std::to_string(m_foundFiles.size()) + " media files.");
    #####:  179:            notifyComplete(m_foundFiles);
        -:  180:        }
        -:  181:        else 
        -:  182:        {
    #####:  183:            LOG_INFO("Scan was stopped by user.");
        -:  184:        }
        -:  185:    }
    =====:  186:    catch (const std::exception& e) 
        -:  187:    {
    =====:  188:        LOG_ERROR("Exception during scan: " + std::string(e.what()));
    =====:  189:    }
        -:  190:    
    #####:  191:    m_isScanning = false;
    #####:  192:}
        -:  193:
    #####:  194:void FileScanner::scanRecursive(const std::string& dirPath, int currentDepth) 
        -:  195:{
    #####:  196:    if (m_shouldStop) 
        -:  197:    {
    #####:  198:        return;
        -:  199:    }
        -:  200:    
    #####:  201:    if (currentDepth > m_maxDepth) 
        -:  202:    {
    #####:  203:        LOG_WARNING("Max depth reached at: " + dirPath);
    #####:  204:        return;
        -:  205:    }
        -:  206:    
        -:  207:    try 
        -:  208:    {
    #####:  209:        for (const auto& entry : fs::directory_iterator(dirPath)) 
        -:  210:        {
    #####:  211:            if (m_shouldStop) 
        -:  212:            {
    #####:  213:                return;
        -:  214:            }
        -:  215:            
        -:  216:            try 
        -:  217:            {
    #####:  218:                if (entry.is_directory()) 
        -:  219:                {
        -:  220:                    // Skip hidden directories
    #####:  221:                    if (entry.path().filename().string()[0] == '.') 
        -:  222:                    {
    #####:  223:                        continue;
        -:  224:                    }
        -:  225:                    
    #####:  226:                    scanRecursive(entry.path().string(), currentDepth + 1);
        -:  227:                }
    #####:  228:                else if (entry.is_regular_file()) 
        -:  229:                {
    #####:  230:                    std::string filePath = entry.path().string();
        -:  231:                    
    #####:  232:                    if (isValidMediaFile(filePath)) 
        -:  233:                    {
    #####:  234:                        models::MediaFileModel media(filePath);
        -:  235:                        
    #####:  236:                        if (media.isValid()) 
        -:  237:                        {
        -:  238:                            // Read metadata using TagLib
        -:  239:                            try 
        -:  240:                            {
    #####:  241:                                TagLib::FileRef file(filePath.c_str());
    #####:  242:                                if (!file.isNull()) 
        -:  243:                                {
    #####:  244:                                    TagLib::Tag* tag = file.tag();
    #####:  245:                                    if (tag) 
        -:  246:                                    {
    #####:  247:                                        std::string title = tag->title().toCString(true);
    #####:  248:                                        std::string artist = tag->artist().toCString(true);
    #####:  249:                                        std::string album = tag->album().toCString(true);
        -:  250:                                        
    #####:  251:                                        if (!title.empty()) media.setTitle(title);
    #####:  252:                                        if (!artist.empty()) media.setArtist(artist);
    #####:  253:                                        if (!album.empty()) media.setAlbum(album);
    #####:  254:                                    }
        -:  255:                                    
    #####:  256:                                    TagLib::AudioProperties* props = file.audioProperties();
    #####:  257:                                    if (props) 
        -:  258:                                    {
    #####:  259:                                        media.setDuration(props->lengthInSeconds());
        -:  260:                                    }
        -:  261:                                }
    #####:  262:                            }
    =====:  263:                            catch (...) 
        -:  264:                            {
        -:  265:                                // Ignore metadata read errors
    =====:  266:                            }
        -:  267:                            
    #####:  268:                            m_foundFiles.push_back(media);
    #####:  269:                            m_scannedCount++;
        -:  270:                            
        -:  271:                            // Notify progress every 10 files
    #####:  272:                            if (m_scannedCount % 10 == 0) 
        -:  273:                            {
    #####:  274:                                notifyProgress(m_scannedCount, filePath);
        -:  275:                            }
        -:  276:                        }
    #####:  277:                    }
        -:  278:                    else
        -:  279:                    {
        -:  280:                        // Log skipped file for verification
        -:  281:                        // LOG_DEBUG("Skipping unsupported file: " + filePath);
        -:  282:                    }
    #####:  283:                }
        -:  284:            }
    =====:  285:            catch (const fs::filesystem_error& e) 
        -:  286:            {
    =====:  287:                LOG_WARNING("Error accessing: " + entry.path().string() + " - " + e.what());
    =====:  288:                continue;
    =====:  289:            }
    #####:  290:        }
        -:  291:    }
    =====:  292:    catch (const fs::filesystem_error& e) 
        -:  293:    {
    =====:  294:        LOG_ERROR("Error scanning directory: " + dirPath + " - " + e.what());
    =====:  295:    }
        -:  296:}
        -:  297:
    #####:  298:bool FileScanner::isValidMediaFile(const std::string& filePath) const 
        -:  299:{
    #####:  300:    std::string extension = getFileExtension(filePath);
    #####:  301:    return hasValidExtension(extension);
    #####:  302:}
        -:  303:
    #####:  304:bool FileScanner::hasValidExtension(const std::string& extension) const 
        -:  305:{
    #####:  306:    std::string lowerExt = toLowerCase(extension);
        -:  307:    
    #####:  308:    return std::find(m_validExtensions.begin(), 
        -:  309:                     m_validExtensions.end(), 
    #####:  310:                     lowerExt) != m_validExtensions.end();
    #####:  311:}
        -:  312:
    #####:  313:std::string FileScanner::getFileExtension(const std::string& filePath) const 
        -:  314:{
    #####:  315:    size_t dotPos = filePath.find_last_of('.');
        -:  316:    
    #####:  317:    if (dotPos == std::string::npos) 
        -:  318:    {
    #####:  319:        return "";
        -:  320:    }
        -:  321:    
    #####:  322:    return filePath.substr(dotPos);
        -:  323:}
        -:  324:
    #####:  325:std::string FileScanner::toLowerCase(const std::string& str) const 
        -:  326:{
    #####:  327:    std::string result = str;
    #####:  328:    std::transform(result.begin(), result.end(), result.begin(), ::tolower);
    #####:  329:    return result;
        -:  330:}
        -:  331:
    #####:  332:void FileScanner::notifyProgress(int count, const std::string& currentPath) 
        -:  333:{
    #####:  334:    if (m_progressCallback) 
        -:  335:    {
    #####:  336:        m_progressCallback(count, currentPath);
        -:  337:    }
    #####:  338:    if (m_progressCallback3) 
        -:  339:    {
    #####:  340:        m_progressCallback3(count, m_totalFiles, currentPath);
        -:  341:    }
    #####:  342:}
        -:  343:
    #####:  344:void FileScanner::notifyComplete(const std::vector<models::MediaFileModel>& results) 
        -:  345:{
    #####:  346:    if (m_completeCallback) 
        -:  347:    {
    #####:  348:        m_completeCallback(results);
        -:  349:    }
    #####:  350:}
        -:  351:
        -:  352:} // namespace services
        -:  353:} // namespace media_player
